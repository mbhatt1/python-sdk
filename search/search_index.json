{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ETDI Security Framework","text":"<p>Enterprise-Grade Security for AI Tool Interactions</p> <p>Prevent tool poisoning, rug poisoning, and unauthorized access with cryptographic verification, behavioral monitoring, and comprehensive audit trails.</p> <p>For a deep dive into ETDI concepts and security architecture, see ETDI Concepts.</p>"},{"location":"#key-security-features","title":"Key Security Features","text":"<ul> <li>\ud83d\udee1\ufe0f Tool Poisoning Prevention: Cryptographic signatures and behavioral verification</li> <li>\ud83d\udc41\ufe0f Rug Poisoning Protection: Change detection and reapproval workflows  </li> <li>\ud83d\udd10 Call Chain Validation: Stack constraints and caller/callee authorization</li> <li>\ud83d\udd11 Enterprise Authentication: OAuth 2.0, SAML, and SSO integration</li> <li>\ud83d\udcca Comprehensive Auditing: Detailed logs for security events, compliance, and forensics.</li> <li>\ud83d\udcc8 Data for Monitoring: Provides rich data to feed into external real-time monitoring and threat detection systems.</li> <li>\ud83d\udd0f Cryptographic Request Signing: Per-request and per-invocation signatures with RSA/ECDSA, key management, and verification.</li> </ul>"},{"location":"#request-signing-implementation","title":"\ud83d\udd10 Request Signing Implementation","text":"<p>ETDI supports cryptographic request signing for all tool invocations and API requests, using RSA/ECDSA algorithms, automatic key management, and seamless integration with tool definitions and FastMCP servers. For technical details and example usage, see Security Features and the Request Signing Examples.</p>"},{"location":"#new-request-signing-implementation","title":"\ud83d\udd10 New Request Signing Implementation","text":"<p>Cryptographic Request Signing Module: - <code>src/mcp/etdi/crypto/request_signer.py</code> \u2013 RSA/ECDSA request signing and verification - <code>src/mcp/etdi/crypto/key_exchange.py</code> \u2013 Secure key exchange and management - <code>tests/etdi/test_request_signing.py</code> \u2013 Comprehensive test suite for signing functionality</p> <p>Request Signing Features: - Multiple Algorithms: Support for RS256, RS384, RS512, ES256, ES384, ES512 - Key Management: Automatic key generation, rotation, and persistence - Tool Integration: Seamless integration with ETDI tool definitions - FastMCP Integration: Request signing support for FastMCP servers - Backward Compatibility: Non-breaking integration with existing tools</p> <p>Example Files Added: - <code>examples/etdi/request_signing_example.py</code> \u2013 Client-side request signing - <code>examples/etdi/request_signing_server_example.py</code> \u2013 Server-side signature verification - <code>examples/etdi/comprehensive_request_signing_example.py</code> \u2013 End-to-end signing workflow</p>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from mcp.etdi import SecureServer, ToolProvider\nfrom mcp.etdi.auth import OAuthHandler\n\n# Create secure server with ETDI protection\nserver = SecureServer(\n    security_level=\"high\",\n    enable_tool_verification=True\n)\n\n# Add OAuth authentication\nauth = OAuthHandler(\n    provider=\"auth0\",\n    domain=\"your-domain.auth0.com\",\n    client_id=\"your-client-id\"\n)\nserver.add_auth_handler(auth)\n\n# Register verified tools\n@server.tool(\"secure_file_read\")\nasync def secure_file_read(path: str) -&gt; str:\n    # Tool implementation with ETDI security\n    return await verified_file_read(path)\n</code></pre>"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<ul> <li>Getting Started: Installation, setup, and your first secure server.</li> <li>Attack Prevention: Comprehensive protection against AI security threats.</li> <li>Security Features: Authentication, authorization, and behavioral verification.</li> <li>Examples &amp; Demos: Real-world examples and interactive demonstrations.</li> </ul>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#mcp.ClientSession","title":"ClientSession","text":"<p>               Bases: <code>BaseSession[ClientRequest, ClientNotification, ClientResult, ServerRequest, ServerNotification]</code></p> Source code in <code>src/mcp/client/session.py</code> <pre><code>class ClientSession(\n    BaseSession[\n        types.ClientRequest,\n        types.ClientNotification,\n        types.ClientResult,\n        types.ServerRequest,\n        types.ServerNotification,\n    ]\n):\n    def __init__(\n        self,\n        read_stream: MemoryObjectReceiveStream[SessionMessage | Exception],\n        write_stream: MemoryObjectSendStream[SessionMessage],\n        read_timeout_seconds: timedelta | None = None,\n        sampling_callback: SamplingFnT | None = None,\n        list_roots_callback: ListRootsFnT | None = None,\n        logging_callback: LoggingFnT | None = None,\n        message_handler: MessageHandlerFnT | None = None,\n        client_info: types.Implementation | None = None,\n    ) -&gt; None:\n        super().__init__(\n            read_stream,\n            write_stream,\n            types.ServerRequest,\n            types.ServerNotification,\n            read_timeout_seconds=read_timeout_seconds,\n        )\n        self._client_info = client_info or DEFAULT_CLIENT_INFO\n        self._sampling_callback = sampling_callback or _default_sampling_callback\n        self._list_roots_callback = list_roots_callback or _default_list_roots_callback\n        self._logging_callback = logging_callback or _default_logging_callback\n        self._message_handler = message_handler or _default_message_handler\n\n    async def initialize(self) -&gt; types.InitializeResult:\n        sampling = types.SamplingCapability()\n        roots = types.RootsCapability(\n            # TODO: Should this be based on whether we\n            # _will_ send notifications, or only whether\n            # they're supported?\n            listChanged=True,\n        )\n\n        result = await self.send_request(\n            types.ClientRequest(\n                types.InitializeRequest(\n                    method=\"initialize\",\n                    params=types.InitializeRequestParams(\n                        protocolVersion=types.LATEST_PROTOCOL_VERSION,\n                        capabilities=types.ClientCapabilities(\n                            sampling=sampling,\n                            experimental=None,\n                            roots=roots,\n                        ),\n                        clientInfo=self._client_info,\n                    ),\n                )\n            ),\n            types.InitializeResult,\n        )\n\n        if result.protocolVersion not in SUPPORTED_PROTOCOL_VERSIONS:\n            raise RuntimeError(\n                \"Unsupported protocol version from the server: \"\n                f\"{result.protocolVersion}\"\n            )\n\n        await self.send_notification(\n            types.ClientNotification(\n                types.InitializedNotification(method=\"notifications/initialized\")\n            )\n        )\n\n        return result\n\n    async def send_ping(self) -&gt; types.EmptyResult:\n        \"\"\"Send a ping request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(\n                types.PingRequest(\n                    method=\"ping\",\n                )\n            ),\n            types.EmptyResult,\n        )\n\n    async def send_progress_notification(\n        self,\n        progress_token: str | int,\n        progress: float,\n        total: float | None = None,\n        message: str | None = None,\n    ) -&gt; None:\n        \"\"\"Send a progress notification.\"\"\"\n        await self.send_notification(\n            types.ClientNotification(\n                types.ProgressNotification(\n                    method=\"notifications/progress\",\n                    params=types.ProgressNotificationParams(\n                        progressToken=progress_token,\n                        progress=progress,\n                        total=total,\n                        message=message,\n                    ),\n                ),\n            )\n        )\n\n    async def set_logging_level(self, level: types.LoggingLevel) -&gt; types.EmptyResult:\n        \"\"\"Send a logging/setLevel request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(\n                types.SetLevelRequest(\n                    method=\"logging/setLevel\",\n                    params=types.SetLevelRequestParams(level=level),\n                )\n            ),\n            types.EmptyResult,\n        )\n\n    async def list_resources(\n        self, cursor: str | None = None\n    ) -&gt; types.ListResourcesResult:\n        \"\"\"Send a resources/list request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(\n                types.ListResourcesRequest(\n                    method=\"resources/list\",\n                    cursor=cursor,\n                )\n            ),\n            types.ListResourcesResult,\n        )\n\n    async def list_resource_templates(\n        self, cursor: str | None = None\n    ) -&gt; types.ListResourceTemplatesResult:\n        \"\"\"Send a resources/templates/list request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(\n                types.ListResourceTemplatesRequest(\n                    method=\"resources/templates/list\",\n                    cursor=cursor,\n                )\n            ),\n            types.ListResourceTemplatesResult,\n        )\n\n    async def read_resource(self, uri: AnyUrl) -&gt; types.ReadResourceResult:\n        \"\"\"Send a resources/read request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(\n                types.ReadResourceRequest(\n                    method=\"resources/read\",\n                    params=types.ReadResourceRequestParams(uri=uri),\n                )\n            ),\n            types.ReadResourceResult,\n        )\n\n    async def subscribe_resource(self, uri: AnyUrl) -&gt; types.EmptyResult:\n        \"\"\"Send a resources/subscribe request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(\n                types.SubscribeRequest(\n                    method=\"resources/subscribe\",\n                    params=types.SubscribeRequestParams(uri=uri),\n                )\n            ),\n            types.EmptyResult,\n        )\n\n    async def unsubscribe_resource(self, uri: AnyUrl) -&gt; types.EmptyResult:\n        \"\"\"Send a resources/unsubscribe request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(\n                types.UnsubscribeRequest(\n                    method=\"resources/unsubscribe\",\n                    params=types.UnsubscribeRequestParams(uri=uri),\n                )\n            ),\n            types.EmptyResult,\n        )\n\n    async def call_tool(\n        self,\n        name: str,\n        arguments: dict[str, Any] | None = None,\n        read_timeout_seconds: timedelta | None = None,\n        progress_callback: ProgressFnT | None = None,\n    ) -&gt; types.CallToolResult:\n        \"\"\"Send a tools/call request with optional progress callback support.\"\"\"\n\n        return await self.send_request(\n            types.ClientRequest(\n                types.CallToolRequest(\n                    method=\"tools/call\",\n                    params=types.CallToolRequestParams(\n                        name=name,\n                        arguments=arguments,\n                    ),\n                )\n            ),\n            types.CallToolResult,\n            request_read_timeout_seconds=read_timeout_seconds,\n            progress_callback=progress_callback,\n        )\n\n    async def list_prompts(self, cursor: str | None = None) -&gt; types.ListPromptsResult:\n        \"\"\"Send a prompts/list request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(\n                types.ListPromptsRequest(\n                    method=\"prompts/list\",\n                    cursor=cursor,\n                )\n            ),\n            types.ListPromptsResult,\n        )\n\n    async def get_prompt(\n        self, name: str, arguments: dict[str, str] | None = None\n    ) -&gt; types.GetPromptResult:\n        \"\"\"Send a prompts/get request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(\n                types.GetPromptRequest(\n                    method=\"prompts/get\",\n                    params=types.GetPromptRequestParams(name=name, arguments=arguments),\n                )\n            ),\n            types.GetPromptResult,\n        )\n\n    async def complete(\n        self,\n        ref: types.ResourceReference | types.PromptReference,\n        argument: dict[str, str],\n    ) -&gt; types.CompleteResult:\n        \"\"\"Send a completion/complete request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(\n                types.CompleteRequest(\n                    method=\"completion/complete\",\n                    params=types.CompleteRequestParams(\n                        ref=ref,\n                        argument=types.CompletionArgument(**argument),\n                    ),\n                )\n            ),\n            types.CompleteResult,\n        )\n\n    async def list_tools(self, cursor: str | None = None) -&gt; types.ListToolsResult:\n        \"\"\"Send a tools/list request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(\n                types.ListToolsRequest(\n                    method=\"tools/list\",\n                    cursor=cursor,\n                )\n            ),\n            types.ListToolsResult,\n        )\n\n    async def send_roots_list_changed(self) -&gt; None:\n        \"\"\"Send a roots/list_changed notification.\"\"\"\n        await self.send_notification(\n            types.ClientNotification(\n                types.RootsListChangedNotification(\n                    method=\"notifications/roots/list_changed\",\n                )\n            )\n        )\n\n    async def _received_request(\n        self, responder: RequestResponder[types.ServerRequest, types.ClientResult]\n    ) -&gt; None:\n        ctx = RequestContext[ClientSession, Any](\n            request_id=responder.request_id,\n            meta=responder.request_meta,\n            session=self,\n            lifespan_context=None,\n        )\n\n        match responder.request.root:\n            case types.CreateMessageRequest(params=params):\n                with responder:\n                    response = await self._sampling_callback(ctx, params)\n                    client_response = ClientResponse.validate_python(response)\n                    await responder.respond(client_response)\n\n            case types.ListRootsRequest():\n                with responder:\n                    response = await self._list_roots_callback(ctx)\n                    client_response = ClientResponse.validate_python(response)\n                    await responder.respond(client_response)\n\n            case types.PingRequest():\n                with responder:\n                    return await responder.respond(\n                        types.ClientResult(root=types.EmptyResult())\n                    )\n\n    async def _handle_incoming(\n        self,\n        req: RequestResponder[types.ServerRequest, types.ClientResult]\n        | types.ServerNotification\n        | Exception,\n    ) -&gt; None:\n        \"\"\"Handle incoming messages by forwarding to the message handler.\"\"\"\n        await self._message_handler(req)\n\n    async def _received_notification(\n        self, notification: types.ServerNotification\n    ) -&gt; None:\n        \"\"\"Handle notifications from the server.\"\"\"\n        # Process specific notification types\n        match notification.root:\n            case types.LoggingMessageNotification(params=params):\n                await self._logging_callback(params)\n            case _:\n                pass\n</code></pre>"},{"location":"api/#mcp.ClientSession.send_ping","title":"send_ping  <code>async</code>","text":"<pre><code>send_ping() -&gt; EmptyResult\n</code></pre> <p>Send a ping request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def send_ping(self) -&gt; types.EmptyResult:\n    \"\"\"Send a ping request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(\n            types.PingRequest(\n                method=\"ping\",\n            )\n        ),\n        types.EmptyResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.send_progress_notification","title":"send_progress_notification  <code>async</code>","text":"<pre><code>send_progress_notification(\n    progress_token: str | int,\n    progress: float,\n    total: float | None = None,\n    message: str | None = None,\n) -&gt; None\n</code></pre> <p>Send a progress notification.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def send_progress_notification(\n    self,\n    progress_token: str | int,\n    progress: float,\n    total: float | None = None,\n    message: str | None = None,\n) -&gt; None:\n    \"\"\"Send a progress notification.\"\"\"\n    await self.send_notification(\n        types.ClientNotification(\n            types.ProgressNotification(\n                method=\"notifications/progress\",\n                params=types.ProgressNotificationParams(\n                    progressToken=progress_token,\n                    progress=progress,\n                    total=total,\n                    message=message,\n                ),\n            ),\n        )\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.set_logging_level","title":"set_logging_level  <code>async</code>","text":"<pre><code>set_logging_level(level: LoggingLevel) -&gt; EmptyResult\n</code></pre> <p>Send a logging/setLevel request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def set_logging_level(self, level: types.LoggingLevel) -&gt; types.EmptyResult:\n    \"\"\"Send a logging/setLevel request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(\n            types.SetLevelRequest(\n                method=\"logging/setLevel\",\n                params=types.SetLevelRequestParams(level=level),\n            )\n        ),\n        types.EmptyResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.list_resources","title":"list_resources  <code>async</code>","text":"<pre><code>list_resources(\n    cursor: str | None = None,\n) -&gt; ListResourcesResult\n</code></pre> <p>Send a resources/list request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def list_resources(\n    self, cursor: str | None = None\n) -&gt; types.ListResourcesResult:\n    \"\"\"Send a resources/list request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(\n            types.ListResourcesRequest(\n                method=\"resources/list\",\n                cursor=cursor,\n            )\n        ),\n        types.ListResourcesResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.list_resource_templates","title":"list_resource_templates  <code>async</code>","text":"<pre><code>list_resource_templates(\n    cursor: str | None = None,\n) -&gt; ListResourceTemplatesResult\n</code></pre> <p>Send a resources/templates/list request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def list_resource_templates(\n    self, cursor: str | None = None\n) -&gt; types.ListResourceTemplatesResult:\n    \"\"\"Send a resources/templates/list request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(\n            types.ListResourceTemplatesRequest(\n                method=\"resources/templates/list\",\n                cursor=cursor,\n            )\n        ),\n        types.ListResourceTemplatesResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.read_resource","title":"read_resource  <code>async</code>","text":"<pre><code>read_resource(uri: AnyUrl) -&gt; ReadResourceResult\n</code></pre> <p>Send a resources/read request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def read_resource(self, uri: AnyUrl) -&gt; types.ReadResourceResult:\n    \"\"\"Send a resources/read request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(\n            types.ReadResourceRequest(\n                method=\"resources/read\",\n                params=types.ReadResourceRequestParams(uri=uri),\n            )\n        ),\n        types.ReadResourceResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.subscribe_resource","title":"subscribe_resource  <code>async</code>","text":"<pre><code>subscribe_resource(uri: AnyUrl) -&gt; EmptyResult\n</code></pre> <p>Send a resources/subscribe request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def subscribe_resource(self, uri: AnyUrl) -&gt; types.EmptyResult:\n    \"\"\"Send a resources/subscribe request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(\n            types.SubscribeRequest(\n                method=\"resources/subscribe\",\n                params=types.SubscribeRequestParams(uri=uri),\n            )\n        ),\n        types.EmptyResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.unsubscribe_resource","title":"unsubscribe_resource  <code>async</code>","text":"<pre><code>unsubscribe_resource(uri: AnyUrl) -&gt; EmptyResult\n</code></pre> <p>Send a resources/unsubscribe request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def unsubscribe_resource(self, uri: AnyUrl) -&gt; types.EmptyResult:\n    \"\"\"Send a resources/unsubscribe request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(\n            types.UnsubscribeRequest(\n                method=\"resources/unsubscribe\",\n                params=types.UnsubscribeRequestParams(uri=uri),\n            )\n        ),\n        types.EmptyResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.call_tool","title":"call_tool  <code>async</code>","text":"<pre><code>call_tool(\n    name: str,\n    arguments: dict[str, Any] | None = None,\n    read_timeout_seconds: timedelta | None = None,\n    progress_callback: ProgressFnT | None = None,\n) -&gt; CallToolResult\n</code></pre> <p>Send a tools/call request with optional progress callback support.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def call_tool(\n    self,\n    name: str,\n    arguments: dict[str, Any] | None = None,\n    read_timeout_seconds: timedelta | None = None,\n    progress_callback: ProgressFnT | None = None,\n) -&gt; types.CallToolResult:\n    \"\"\"Send a tools/call request with optional progress callback support.\"\"\"\n\n    return await self.send_request(\n        types.ClientRequest(\n            types.CallToolRequest(\n                method=\"tools/call\",\n                params=types.CallToolRequestParams(\n                    name=name,\n                    arguments=arguments,\n                ),\n            )\n        ),\n        types.CallToolResult,\n        request_read_timeout_seconds=read_timeout_seconds,\n        progress_callback=progress_callback,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.list_prompts","title":"list_prompts  <code>async</code>","text":"<pre><code>list_prompts(\n    cursor: str | None = None,\n) -&gt; ListPromptsResult\n</code></pre> <p>Send a prompts/list request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def list_prompts(self, cursor: str | None = None) -&gt; types.ListPromptsResult:\n    \"\"\"Send a prompts/list request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(\n            types.ListPromptsRequest(\n                method=\"prompts/list\",\n                cursor=cursor,\n            )\n        ),\n        types.ListPromptsResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.get_prompt","title":"get_prompt  <code>async</code>","text":"<pre><code>get_prompt(\n    name: str, arguments: dict[str, str] | None = None\n) -&gt; GetPromptResult\n</code></pre> <p>Send a prompts/get request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def get_prompt(\n    self, name: str, arguments: dict[str, str] | None = None\n) -&gt; types.GetPromptResult:\n    \"\"\"Send a prompts/get request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(\n            types.GetPromptRequest(\n                method=\"prompts/get\",\n                params=types.GetPromptRequestParams(name=name, arguments=arguments),\n            )\n        ),\n        types.GetPromptResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.complete","title":"complete  <code>async</code>","text":"<pre><code>complete(\n    ref: ResourceReference | PromptReference,\n    argument: dict[str, str],\n) -&gt; CompleteResult\n</code></pre> <p>Send a completion/complete request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def complete(\n    self,\n    ref: types.ResourceReference | types.PromptReference,\n    argument: dict[str, str],\n) -&gt; types.CompleteResult:\n    \"\"\"Send a completion/complete request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(\n            types.CompleteRequest(\n                method=\"completion/complete\",\n                params=types.CompleteRequestParams(\n                    ref=ref,\n                    argument=types.CompletionArgument(**argument),\n                ),\n            )\n        ),\n        types.CompleteResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.list_tools","title":"list_tools  <code>async</code>","text":"<pre><code>list_tools(cursor: str | None = None) -&gt; ListToolsResult\n</code></pre> <p>Send a tools/list request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def list_tools(self, cursor: str | None = None) -&gt; types.ListToolsResult:\n    \"\"\"Send a tools/list request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(\n            types.ListToolsRequest(\n                method=\"tools/list\",\n                cursor=cursor,\n            )\n        ),\n        types.ListToolsResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.send_roots_list_changed","title":"send_roots_list_changed  <code>async</code>","text":"<pre><code>send_roots_list_changed() -&gt; None\n</code></pre> <p>Send a roots/list_changed notification.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def send_roots_list_changed(self) -&gt; None:\n    \"\"\"Send a roots/list_changed notification.\"\"\"\n    await self.send_notification(\n        types.ClientNotification(\n            types.RootsListChangedNotification(\n                method=\"notifications/roots/list_changed\",\n            )\n        )\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSessionGroup","title":"ClientSessionGroup","text":"<p>Client for managing connections to multiple MCP servers.</p> <p>This class is responsible for encapsulating management of server connections. It aggregates tools, resources, and prompts from all connected servers.</p> <p>For auxiliary handlers, such as resource subscription, this is delegated to the client and can be accessed via the session.</p> Example Usage <p>name_fn = lambda name, server_info: f\"{(server_info.name)}-{name}\" async with ClientSessionGroup(component_name_hook=name_fn) as group:     for server_params in server_params:         group.connect_to_server(server_param)     ...</p> Source code in <code>src/mcp/client/session_group.py</code> <pre><code>class ClientSessionGroup:\n    \"\"\"Client for managing connections to multiple MCP servers.\n\n    This class is responsible for encapsulating management of server connections.\n    It aggregates tools, resources, and prompts from all connected servers.\n\n    For auxiliary handlers, such as resource subscription, this is delegated to\n    the client and can be accessed via the session.\n\n    Example Usage:\n        name_fn = lambda name, server_info: f\"{(server_info.name)}-{name}\"\n        async with ClientSessionGroup(component_name_hook=name_fn) as group:\n            for server_params in server_params:\n                group.connect_to_server(server_param)\n            ...\n\n    \"\"\"\n\n    class _ComponentNames(BaseModel):\n        \"\"\"Used for reverse index to find components.\"\"\"\n\n        prompts: set[str] = set()\n        resources: set[str] = set()\n        tools: set[str] = set()\n\n    # Standard MCP components.\n    _prompts: dict[str, types.Prompt]\n    _resources: dict[str, types.Resource]\n    _tools: dict[str, types.Tool]\n\n    # Client-server connection management.\n    _sessions: dict[mcp.ClientSession, _ComponentNames]\n    _tool_to_session: dict[str, mcp.ClientSession]\n    _exit_stack: contextlib.AsyncExitStack\n    _session_exit_stacks: dict[mcp.ClientSession, contextlib.AsyncExitStack]\n\n    # Optional fn consuming (component_name, serverInfo) for custom names.\n    # This is provide a means to mitigate naming conflicts across servers.\n    # Example: (tool_name, serverInfo) =&gt; \"{result.serverInfo.name}.{tool_name}\"\n    _ComponentNameHook: TypeAlias = Callable[[str, types.Implementation], str]\n    _component_name_hook: _ComponentNameHook | None\n\n    def __init__(\n        self,\n        exit_stack: contextlib.AsyncExitStack | None = None,\n        component_name_hook: _ComponentNameHook | None = None,\n    ) -&gt; None:\n        \"\"\"Initializes the MCP client.\"\"\"\n\n        self._tools = {}\n        self._resources = {}\n        self._prompts = {}\n\n        self._sessions = {}\n        self._tool_to_session = {}\n        if exit_stack is None:\n            self._exit_stack = contextlib.AsyncExitStack()\n            self._owns_exit_stack = True\n        else:\n            self._exit_stack = exit_stack\n            self._owns_exit_stack = False\n        self._session_exit_stacks = {}\n        self._component_name_hook = component_name_hook\n\n    async def __aenter__(self) -&gt; Self:\n        # Enter the exit stack only if we created it ourselves\n        if self._owns_exit_stack:\n            await self._exit_stack.__aenter__()\n        return self\n\n    async def __aexit__(\n        self,\n        _exc_type: type[BaseException] | None,\n        _exc_val: BaseException | None,\n        _exc_tb: TracebackType | None,\n    ) -&gt; bool | None:\n        \"\"\"Closes session exit stacks and main exit stack upon completion.\"\"\"\n\n        # Concurrently close session stacks.\n        async with anyio.create_task_group() as tg:\n            for exit_stack in self._session_exit_stacks.values():\n                tg.start_soon(exit_stack.aclose)\n\n        # Only close the main exit stack if we created it\n        if self._owns_exit_stack:\n            await self._exit_stack.aclose()\n\n    @property\n    def sessions(self) -&gt; list[mcp.ClientSession]:\n        \"\"\"Returns the list of sessions being managed.\"\"\"\n        return list(self._sessions.keys())\n\n    @property\n    def prompts(self) -&gt; dict[str, types.Prompt]:\n        \"\"\"Returns the prompts as a dictionary of names to prompts.\"\"\"\n        return self._prompts\n\n    @property\n    def resources(self) -&gt; dict[str, types.Resource]:\n        \"\"\"Returns the resources as a dictionary of names to resources.\"\"\"\n        return self._resources\n\n    @property\n    def tools(self) -&gt; dict[str, types.Tool]:\n        \"\"\"Returns the tools as a dictionary of names to tools.\"\"\"\n        return self._tools\n\n    async def call_tool(self, name: str, args: dict[str, Any]) -&gt; types.CallToolResult:\n        \"\"\"Executes a tool given its name and arguments.\"\"\"\n        session = self._tool_to_session[name]\n        session_tool_name = self.tools[name].name\n        return await session.call_tool(session_tool_name, args)\n\n    async def disconnect_from_server(self, session: mcp.ClientSession) -&gt; None:\n        \"\"\"Disconnects from a single MCP server.\"\"\"\n\n        session_known_for_components = session in self._sessions\n        session_known_for_stack = session in self._session_exit_stacks\n\n        if not session_known_for_components and not session_known_for_stack:\n            raise McpError(\n                types.ErrorData(\n                    code=types.INVALID_PARAMS,\n                    message=\"Provided session is not managed or already disconnected.\",\n                )\n            )\n\n        if session_known_for_components:\n            component_names = self._sessions.pop(session)  # Pop from _sessions tracking\n\n            # Remove prompts associated with the session.\n            for name in component_names.prompts:\n                if name in self._prompts:\n                    del self._prompts[name]\n            # Remove resources associated with the session.\n            for name in component_names.resources:\n                if name in self._resources:\n                    del self._resources[name]\n            # Remove tools associated with the session.\n            for name in component_names.tools:\n                if name in self._tools:\n                    del self._tools[name]\n                if name in self._tool_to_session:\n                    del self._tool_to_session[name]\n\n        # Clean up the session's resources via its dedicated exit stack\n        if session_known_for_stack:\n            session_stack_to_close = self._session_exit_stacks.pop(session)\n            await session_stack_to_close.aclose()\n\n    async def connect_with_session(\n        self, server_info: types.Implementation, session: mcp.ClientSession\n    ) -&gt; mcp.ClientSession:\n        \"\"\"Connects to a single MCP server.\"\"\"\n        await self._aggregate_components(server_info, session)\n        return session\n\n    async def connect_to_server(\n        self,\n        server_params: ServerParameters,\n    ) -&gt; mcp.ClientSession:\n        \"\"\"Connects to a single MCP server.\"\"\"\n        server_info, session = await self._establish_session(server_params)\n        return await self.connect_with_session(server_info, session)\n\n    async def _establish_session(\n        self, server_params: ServerParameters\n    ) -&gt; tuple[types.Implementation, mcp.ClientSession]:\n        \"\"\"Establish a client session to an MCP server.\"\"\"\n\n        session_stack = contextlib.AsyncExitStack()\n        try:\n            # Create read and write streams that facilitate io with the server.\n            if isinstance(server_params, StdioServerParameters):\n                client = mcp.stdio_client(server_params)\n                read, write = await session_stack.enter_async_context(client)\n            elif isinstance(server_params, SseServerParameters):\n                client = sse_client(\n                    url=server_params.url,\n                    headers=server_params.headers,\n                    timeout=server_params.timeout,\n                    sse_read_timeout=server_params.sse_read_timeout,\n                )\n                read, write = await session_stack.enter_async_context(client)\n            else:\n                client = streamablehttp_client(\n                    url=server_params.url,\n                    headers=server_params.headers,\n                    timeout=server_params.timeout,\n                    sse_read_timeout=server_params.sse_read_timeout,\n                    terminate_on_close=server_params.terminate_on_close,\n                )\n                read, write, _ = await session_stack.enter_async_context(client)\n\n            session = await session_stack.enter_async_context(\n                mcp.ClientSession(read, write)\n            )\n            result = await session.initialize()\n\n            # Session successfully initialized.\n            # Store its stack and register the stack with the main group stack.\n            self._session_exit_stacks[session] = session_stack\n            # session_stack itself becomes a resource managed by the\n            # main _exit_stack.\n            await self._exit_stack.enter_async_context(session_stack)\n\n            return result.serverInfo, session\n        except Exception:\n            # If anything during this setup fails, ensure the session-specific\n            # stack is closed.\n            await session_stack.aclose()\n            raise\n\n    async def _aggregate_components(\n        self, server_info: types.Implementation, session: mcp.ClientSession\n    ) -&gt; None:\n        \"\"\"Aggregates prompts, resources, and tools from a given session.\"\"\"\n\n        # Create a reverse index so we can find all prompts, resources, and\n        # tools belonging to this session. Used for removing components from\n        # the session group via self.disconnect_from_server.\n        component_names = self._ComponentNames()\n\n        # Temporary components dicts. We do not want to modify the aggregate\n        # lists in case of an intermediate failure.\n        prompts_temp: dict[str, types.Prompt] = {}\n        resources_temp: dict[str, types.Resource] = {}\n        tools_temp: dict[str, types.Tool] = {}\n        tool_to_session_temp: dict[str, mcp.ClientSession] = {}\n\n        # Query the server for its prompts and aggregate to list.\n        try:\n            prompts = (await session.list_prompts()).prompts\n            for prompt in prompts:\n                name = self._component_name(prompt.name, server_info)\n                prompts_temp[name] = prompt\n                component_names.prompts.add(name)\n        except McpError as err:\n            logging.warning(f\"Could not fetch prompts: {err}\")\n\n        # Query the server for its resources and aggregate to list.\n        try:\n            resources = (await session.list_resources()).resources\n            for resource in resources:\n                name = self._component_name(resource.name, server_info)\n                resources_temp[name] = resource\n                component_names.resources.add(name)\n        except McpError as err:\n            logging.warning(f\"Could not fetch resources: {err}\")\n\n        # Query the server for its tools and aggregate to list.\n        try:\n            tools = (await session.list_tools()).tools\n            for tool in tools:\n                name = self._component_name(tool.name, server_info)\n                tools_temp[name] = tool\n                tool_to_session_temp[name] = session\n                component_names.tools.add(name)\n        except McpError as err:\n            logging.warning(f\"Could not fetch tools: {err}\")\n\n        # Clean up exit stack for session if we couldn't retrieve anything\n        # from the server.\n        if not any((prompts_temp, resources_temp, tools_temp)):\n            del self._session_exit_stacks[session]\n\n        # Check for duplicates.\n        matching_prompts = prompts_temp.keys() &amp; self._prompts.keys()\n        if matching_prompts:\n            raise McpError(\n                types.ErrorData(\n                    code=types.INVALID_PARAMS,\n                    message=f\"{matching_prompts} already exist in group prompts.\",\n                )\n            )\n        matching_resources = resources_temp.keys() &amp; self._resources.keys()\n        if matching_resources:\n            raise McpError(\n                types.ErrorData(\n                    code=types.INVALID_PARAMS,\n                    message=f\"{matching_resources} already exist in group resources.\",\n                )\n            )\n        matching_tools = tools_temp.keys() &amp; self._tools.keys()\n        if matching_tools:\n            raise McpError(\n                types.ErrorData(\n                    code=types.INVALID_PARAMS,\n                    message=f\"{matching_tools} already exist in group tools.\",\n                )\n            )\n\n        # Aggregate components.\n        self._sessions[session] = component_names\n        self._prompts.update(prompts_temp)\n        self._resources.update(resources_temp)\n        self._tools.update(tools_temp)\n        self._tool_to_session.update(tool_to_session_temp)\n\n    def _component_name(self, name: str, server_info: types.Implementation) -&gt; str:\n        if self._component_name_hook:\n            return self._component_name_hook(name, server_info)\n        return name\n</code></pre>"},{"location":"api/#mcp.ClientSessionGroup.__init__","title":"__init__","text":"<pre><code>__init__(\n    exit_stack: AsyncExitStack | None = None,\n    component_name_hook: _ComponentNameHook | None = None,\n) -&gt; None\n</code></pre> <p>Initializes the MCP client.</p> Source code in <code>src/mcp/client/session_group.py</code> <pre><code>def __init__(\n    self,\n    exit_stack: contextlib.AsyncExitStack | None = None,\n    component_name_hook: _ComponentNameHook | None = None,\n) -&gt; None:\n    \"\"\"Initializes the MCP client.\"\"\"\n\n    self._tools = {}\n    self._resources = {}\n    self._prompts = {}\n\n    self._sessions = {}\n    self._tool_to_session = {}\n    if exit_stack is None:\n        self._exit_stack = contextlib.AsyncExitStack()\n        self._owns_exit_stack = True\n    else:\n        self._exit_stack = exit_stack\n        self._owns_exit_stack = False\n    self._session_exit_stacks = {}\n    self._component_name_hook = component_name_hook\n</code></pre>"},{"location":"api/#mcp.ClientSessionGroup.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    _exc_type: type[BaseException] | None,\n    _exc_val: BaseException | None,\n    _exc_tb: TracebackType | None,\n) -&gt; bool | None\n</code></pre> <p>Closes session exit stacks and main exit stack upon completion.</p> Source code in <code>src/mcp/client/session_group.py</code> <pre><code>async def __aexit__(\n    self,\n    _exc_type: type[BaseException] | None,\n    _exc_val: BaseException | None,\n    _exc_tb: TracebackType | None,\n) -&gt; bool | None:\n    \"\"\"Closes session exit stacks and main exit stack upon completion.\"\"\"\n\n    # Concurrently close session stacks.\n    async with anyio.create_task_group() as tg:\n        for exit_stack in self._session_exit_stacks.values():\n            tg.start_soon(exit_stack.aclose)\n\n    # Only close the main exit stack if we created it\n    if self._owns_exit_stack:\n        await self._exit_stack.aclose()\n</code></pre>"},{"location":"api/#mcp.ClientSessionGroup.sessions","title":"sessions  <code>property</code>","text":"<pre><code>sessions: list[ClientSession]\n</code></pre> <p>Returns the list of sessions being managed.</p>"},{"location":"api/#mcp.ClientSessionGroup.prompts","title":"prompts  <code>property</code>","text":"<pre><code>prompts: dict[str, Prompt]\n</code></pre> <p>Returns the prompts as a dictionary of names to prompts.</p>"},{"location":"api/#mcp.ClientSessionGroup.resources","title":"resources  <code>property</code>","text":"<pre><code>resources: dict[str, Resource]\n</code></pre> <p>Returns the resources as a dictionary of names to resources.</p>"},{"location":"api/#mcp.ClientSessionGroup.tools","title":"tools  <code>property</code>","text":"<pre><code>tools: dict[str, Tool]\n</code></pre> <p>Returns the tools as a dictionary of names to tools.</p>"},{"location":"api/#mcp.ClientSessionGroup.call_tool","title":"call_tool  <code>async</code>","text":"<pre><code>call_tool(\n    name: str, args: dict[str, Any]\n) -&gt; CallToolResult\n</code></pre> <p>Executes a tool given its name and arguments.</p> Source code in <code>src/mcp/client/session_group.py</code> <pre><code>async def call_tool(self, name: str, args: dict[str, Any]) -&gt; types.CallToolResult:\n    \"\"\"Executes a tool given its name and arguments.\"\"\"\n    session = self._tool_to_session[name]\n    session_tool_name = self.tools[name].name\n    return await session.call_tool(session_tool_name, args)\n</code></pre>"},{"location":"api/#mcp.ClientSessionGroup.disconnect_from_server","title":"disconnect_from_server  <code>async</code>","text":"<pre><code>disconnect_from_server(session: ClientSession) -&gt; None\n</code></pre> <p>Disconnects from a single MCP server.</p> Source code in <code>src/mcp/client/session_group.py</code> <pre><code>async def disconnect_from_server(self, session: mcp.ClientSession) -&gt; None:\n    \"\"\"Disconnects from a single MCP server.\"\"\"\n\n    session_known_for_components = session in self._sessions\n    session_known_for_stack = session in self._session_exit_stacks\n\n    if not session_known_for_components and not session_known_for_stack:\n        raise McpError(\n            types.ErrorData(\n                code=types.INVALID_PARAMS,\n                message=\"Provided session is not managed or already disconnected.\",\n            )\n        )\n\n    if session_known_for_components:\n        component_names = self._sessions.pop(session)  # Pop from _sessions tracking\n\n        # Remove prompts associated with the session.\n        for name in component_names.prompts:\n            if name in self._prompts:\n                del self._prompts[name]\n        # Remove resources associated with the session.\n        for name in component_names.resources:\n            if name in self._resources:\n                del self._resources[name]\n        # Remove tools associated with the session.\n        for name in component_names.tools:\n            if name in self._tools:\n                del self._tools[name]\n            if name in self._tool_to_session:\n                del self._tool_to_session[name]\n\n    # Clean up the session's resources via its dedicated exit stack\n    if session_known_for_stack:\n        session_stack_to_close = self._session_exit_stacks.pop(session)\n        await session_stack_to_close.aclose()\n</code></pre>"},{"location":"api/#mcp.ClientSessionGroup.connect_with_session","title":"connect_with_session  <code>async</code>","text":"<pre><code>connect_with_session(\n    server_info: Implementation, session: ClientSession\n) -&gt; ClientSession\n</code></pre> <p>Connects to a single MCP server.</p> Source code in <code>src/mcp/client/session_group.py</code> <pre><code>async def connect_with_session(\n    self, server_info: types.Implementation, session: mcp.ClientSession\n) -&gt; mcp.ClientSession:\n    \"\"\"Connects to a single MCP server.\"\"\"\n    await self._aggregate_components(server_info, session)\n    return session\n</code></pre>"},{"location":"api/#mcp.ClientSessionGroup.connect_to_server","title":"connect_to_server  <code>async</code>","text":"<pre><code>connect_to_server(\n    server_params: ServerParameters,\n) -&gt; ClientSession\n</code></pre> <p>Connects to a single MCP server.</p> Source code in <code>src/mcp/client/session_group.py</code> <pre><code>async def connect_to_server(\n    self,\n    server_params: ServerParameters,\n) -&gt; mcp.ClientSession:\n    \"\"\"Connects to a single MCP server.\"\"\"\n    server_info, session = await self._establish_session(server_params)\n    return await self.connect_with_session(server_info, session)\n</code></pre>"},{"location":"api/#mcp.StdioServerParameters","title":"StdioServerParameters","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/mcp/client/stdio/__init__.py</code> <pre><code>class StdioServerParameters(BaseModel):\n    command: str\n    \"\"\"The executable to run to start the server.\"\"\"\n\n    args: list[str] = Field(default_factory=list)\n    \"\"\"Command line arguments to pass to the executable.\"\"\"\n\n    env: dict[str, str] | None = None\n    \"\"\"\n    The environment to use when spawning the process.\n\n    If not specified, the result of get_default_environment() will be used.\n    \"\"\"\n\n    cwd: str | Path | None = None\n    \"\"\"The working directory to use when spawning the process.\"\"\"\n\n    encoding: str = \"utf-8\"\n    \"\"\"\n    The text encoding used when sending/receiving messages to the server\n\n    defaults to utf-8\n    \"\"\"\n\n    encoding_error_handler: Literal[\"strict\", \"ignore\", \"replace\"] = \"strict\"\n    \"\"\"\n    The text encoding error handler.\n\n    See https://docs.python.org/3/library/codecs.html#codec-base-classes for\n    explanations of possible values\n    \"\"\"\n</code></pre>"},{"location":"api/#mcp.StdioServerParameters.command","title":"command  <code>instance-attribute</code>","text":"<pre><code>command: str\n</code></pre> <p>The executable to run to start the server.</p>"},{"location":"api/#mcp.StdioServerParameters.args","title":"args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>args: list[str] = Field(default_factory=list)\n</code></pre> <p>Command line arguments to pass to the executable.</p>"},{"location":"api/#mcp.StdioServerParameters.env","title":"env  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>env: dict[str, str] | None = None\n</code></pre> <p>The environment to use when spawning the process.</p> <p>If not specified, the result of get_default_environment() will be used.</p>"},{"location":"api/#mcp.StdioServerParameters.cwd","title":"cwd  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cwd: str | Path | None = None\n</code></pre> <p>The working directory to use when spawning the process.</p>"},{"location":"api/#mcp.StdioServerParameters.encoding","title":"encoding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>encoding: str = 'utf-8'\n</code></pre> <p>The text encoding used when sending/receiving messages to the server</p> <p>defaults to utf-8</p>"},{"location":"api/#mcp.StdioServerParameters.encoding_error_handler","title":"encoding_error_handler  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>encoding_error_handler: Literal[\n    \"strict\", \"ignore\", \"replace\"\n] = \"strict\"\n</code></pre> <p>The text encoding error handler.</p> <p>See https://docs.python.org/3/library/codecs.html#codec-base-classes for explanations of possible values</p>"},{"location":"api/#mcp.stdio_client","title":"stdio_client  <code>async</code>","text":"<pre><code>stdio_client(\n    server: StdioServerParameters, errlog: TextIO = stderr\n)\n</code></pre> <p>Client transport for stdio: this will connect to a server by spawning a process and communicating with it over stdin/stdout.</p> Source code in <code>src/mcp/client/stdio/__init__.py</code> <pre><code>@asynccontextmanager\nasync def stdio_client(server: StdioServerParameters, errlog: TextIO = sys.stderr):\n    \"\"\"\n    Client transport for stdio: this will connect to a server by spawning a\n    process and communicating with it over stdin/stdout.\n    \"\"\"\n    read_stream: MemoryObjectReceiveStream[SessionMessage | Exception]\n    read_stream_writer: MemoryObjectSendStream[SessionMessage | Exception]\n\n    write_stream: MemoryObjectSendStream[SessionMessage]\n    write_stream_reader: MemoryObjectReceiveStream[SessionMessage]\n\n    read_stream_writer, read_stream = anyio.create_memory_object_stream(0)\n    write_stream, write_stream_reader = anyio.create_memory_object_stream(0)\n\n    command = _get_executable_command(server.command)\n\n    # Open process with stderr piped for capture\n    process = await _create_platform_compatible_process(\n        command=command,\n        args=server.args,\n        env=(\n            {**get_default_environment(), **server.env}\n            if server.env is not None\n            else get_default_environment()\n        ),\n        errlog=errlog,\n        cwd=server.cwd,\n    )\n\n    async def stdout_reader():\n        assert process.stdout, \"Opened process is missing stdout\"\n\n        try:\n            async with read_stream_writer:\n                buffer = \"\"\n                async for chunk in TextReceiveStream(\n                    process.stdout,\n                    encoding=server.encoding,\n                    errors=server.encoding_error_handler,\n                ):\n                    lines = (buffer + chunk).split(\"\\n\")\n                    buffer = lines.pop()\n\n                    for line in lines:\n                        try:\n                            message = types.JSONRPCMessage.model_validate_json(line)\n                        except Exception as exc:\n                            await read_stream_writer.send(exc)\n                            continue\n\n                        session_message = SessionMessage(message)\n                        await read_stream_writer.send(session_message)\n        except anyio.ClosedResourceError:\n            await anyio.lowlevel.checkpoint()\n\n    async def stdin_writer():\n        assert process.stdin, \"Opened process is missing stdin\"\n\n        try:\n            async with write_stream_reader:\n                async for session_message in write_stream_reader:\n                    json = session_message.message.model_dump_json(\n                        by_alias=True, exclude_none=True\n                    )\n                    await process.stdin.send(\n                        (json + \"\\n\").encode(\n                            encoding=server.encoding,\n                            errors=server.encoding_error_handler,\n                        )\n                    )\n        except anyio.ClosedResourceError:\n            await anyio.lowlevel.checkpoint()\n\n    async with (\n        anyio.create_task_group() as tg,\n        process,\n    ):\n        tg.start_soon(stdout_reader)\n        tg.start_soon(stdin_writer)\n        try:\n            yield read_stream, write_stream\n        finally:\n            # Clean up process to prevent any dangling orphaned processes\n            if sys.platform == \"win32\":\n                await terminate_windows_process(process)\n            else:\n                process.terminate()\n            await read_stream.aclose()\n            await write_stream.aclose()\n</code></pre>"},{"location":"api/#mcp.ServerSession","title":"ServerSession","text":"<p>               Bases: <code>BaseSession[ServerRequest, ServerNotification, ServerResult, ClientRequest, ClientNotification]</code></p> Source code in <code>src/mcp/server/session.py</code> <pre><code>class ServerSession(\n    BaseSession[\n        types.ServerRequest,\n        types.ServerNotification,\n        types.ServerResult,\n        types.ClientRequest,\n        types.ClientNotification,\n    ]\n):\n    _initialized: InitializationState = InitializationState.NotInitialized\n    _client_params: types.InitializeRequestParams | None = None\n\n    def __init__(\n        self,\n        read_stream: MemoryObjectReceiveStream[SessionMessage | Exception],\n        write_stream: MemoryObjectSendStream[SessionMessage],\n        init_options: InitializationOptions,\n        stateless: bool = False,\n    ) -&gt; None:\n        super().__init__(\n            read_stream, write_stream, types.ClientRequest, types.ClientNotification\n        )\n        self._initialization_state = (\n            InitializationState.Initialized\n            if stateless\n            else InitializationState.NotInitialized\n        )\n\n        self._init_options = init_options\n        self._incoming_message_stream_writer, self._incoming_message_stream_reader = (\n            anyio.create_memory_object_stream[ServerRequestResponder](0)\n        )\n        self._exit_stack.push_async_callback(\n            lambda: self._incoming_message_stream_reader.aclose()\n        )\n\n    @property\n    def client_params(self) -&gt; types.InitializeRequestParams | None:\n        return self._client_params\n\n    def check_client_capability(self, capability: types.ClientCapabilities) -&gt; bool:\n        \"\"\"Check if the client supports a specific capability.\"\"\"\n        if self._client_params is None:\n            return False\n\n        # Get client capabilities from initialization params\n        client_caps = self._client_params.capabilities\n\n        # Check each specified capability in the passed in capability object\n        if capability.roots is not None:\n            if client_caps.roots is None:\n                return False\n            if capability.roots.listChanged and not client_caps.roots.listChanged:\n                return False\n\n        if capability.sampling is not None:\n            if client_caps.sampling is None:\n                return False\n\n        if capability.experimental is not None:\n            if client_caps.experimental is None:\n                return False\n            # Check each experimental capability\n            for exp_key, exp_value in capability.experimental.items():\n                if (\n                    exp_key not in client_caps.experimental\n                    or client_caps.experimental[exp_key] != exp_value\n                ):\n                    return False\n\n        return True\n\n    async def _receive_loop(self) -&gt; None:\n        async with self._incoming_message_stream_writer:\n            await super()._receive_loop()\n\n    async def _received_request(\n        self, responder: RequestResponder[types.ClientRequest, types.ServerResult]\n    ):\n        match responder.request.root:\n            case types.InitializeRequest(params=params):\n                requested_version = params.protocolVersion\n                self._initialization_state = InitializationState.Initializing\n                self._client_params = params\n                with responder:\n                    await responder.respond(\n                        types.ServerResult(\n                            types.InitializeResult(\n                                protocolVersion=requested_version\n                                if requested_version in SUPPORTED_PROTOCOL_VERSIONS\n                                else types.LATEST_PROTOCOL_VERSION,\n                                capabilities=self._init_options.capabilities,\n                                serverInfo=types.Implementation(\n                                    name=self._init_options.server_name,\n                                    version=self._init_options.server_version,\n                                ),\n                                instructions=self._init_options.instructions,\n                            )\n                        )\n                    )\n            case _:\n                if self._initialization_state != InitializationState.Initialized:\n                    raise RuntimeError(\n                        \"Received request before initialization was complete\"\n                    )\n\n    async def _received_notification(\n        self, notification: types.ClientNotification\n    ) -&gt; None:\n        # Need this to avoid ASYNC910\n        await anyio.lowlevel.checkpoint()\n        match notification.root:\n            case types.InitializedNotification():\n                self._initialization_state = InitializationState.Initialized\n            case _:\n                if self._initialization_state != InitializationState.Initialized:\n                    raise RuntimeError(\n                        \"Received notification before initialization was complete\"\n                    )\n\n    async def send_log_message(\n        self,\n        level: types.LoggingLevel,\n        data: Any,\n        logger: str | None = None,\n        related_request_id: types.RequestId | None = None,\n    ) -&gt; None:\n        \"\"\"Send a log message notification.\"\"\"\n        await self.send_notification(\n            types.ServerNotification(\n                types.LoggingMessageNotification(\n                    method=\"notifications/message\",\n                    params=types.LoggingMessageNotificationParams(\n                        level=level,\n                        data=data,\n                        logger=logger,\n                    ),\n                )\n            ),\n            related_request_id,\n        )\n\n    async def send_resource_updated(self, uri: AnyUrl) -&gt; None:\n        \"\"\"Send a resource updated notification.\"\"\"\n        await self.send_notification(\n            types.ServerNotification(\n                types.ResourceUpdatedNotification(\n                    method=\"notifications/resources/updated\",\n                    params=types.ResourceUpdatedNotificationParams(uri=uri),\n                )\n            )\n        )\n\n    async def create_message(\n        self,\n        messages: list[types.SamplingMessage],\n        *,\n        max_tokens: int,\n        system_prompt: str | None = None,\n        include_context: types.IncludeContext | None = None,\n        temperature: float | None = None,\n        stop_sequences: list[str] | None = None,\n        metadata: dict[str, Any] | None = None,\n        model_preferences: types.ModelPreferences | None = None,\n        related_request_id: types.RequestId | None = None,\n    ) -&gt; types.CreateMessageResult:\n        \"\"\"Send a sampling/create_message request.\"\"\"\n        return await self.send_request(\n            request=types.ServerRequest(\n                types.CreateMessageRequest(\n                    method=\"sampling/createMessage\",\n                    params=types.CreateMessageRequestParams(\n                        messages=messages,\n                        systemPrompt=system_prompt,\n                        includeContext=include_context,\n                        temperature=temperature,\n                        maxTokens=max_tokens,\n                        stopSequences=stop_sequences,\n                        metadata=metadata,\n                        modelPreferences=model_preferences,\n                    ),\n                )\n            ),\n            result_type=types.CreateMessageResult,\n            metadata=ServerMessageMetadata(\n                related_request_id=related_request_id,\n            ),\n        )\n\n    async def list_roots(self) -&gt; types.ListRootsResult:\n        \"\"\"Send a roots/list request.\"\"\"\n        return await self.send_request(\n            types.ServerRequest(\n                types.ListRootsRequest(\n                    method=\"roots/list\",\n                )\n            ),\n            types.ListRootsResult,\n        )\n\n    async def send_ping(self) -&gt; types.EmptyResult:\n        \"\"\"Send a ping request.\"\"\"\n        return await self.send_request(\n            types.ServerRequest(\n                types.PingRequest(\n                    method=\"ping\",\n                )\n            ),\n            types.EmptyResult,\n        )\n\n    async def send_progress_notification(\n        self,\n        progress_token: str | int,\n        progress: float,\n        total: float | None = None,\n        message: str | None = None,\n        related_request_id: str | None = None,\n    ) -&gt; None:\n        \"\"\"Send a progress notification.\"\"\"\n        await self.send_notification(\n            types.ServerNotification(\n                types.ProgressNotification(\n                    method=\"notifications/progress\",\n                    params=types.ProgressNotificationParams(\n                        progressToken=progress_token,\n                        progress=progress,\n                        total=total,\n                        message=message,\n                    ),\n                )\n            ),\n            related_request_id,\n        )\n\n    async def send_resource_list_changed(self) -&gt; None:\n        \"\"\"Send a resource list changed notification.\"\"\"\n        await self.send_notification(\n            types.ServerNotification(\n                types.ResourceListChangedNotification(\n                    method=\"notifications/resources/list_changed\",\n                )\n            )\n        )\n\n    async def send_tool_list_changed(self) -&gt; None:\n        \"\"\"Send a tool list changed notification.\"\"\"\n        await self.send_notification(\n            types.ServerNotification(\n                types.ToolListChangedNotification(\n                    method=\"notifications/tools/list_changed\",\n                )\n            )\n        )\n\n    async def send_prompt_list_changed(self) -&gt; None:\n        \"\"\"Send a prompt list changed notification.\"\"\"\n        await self.send_notification(\n            types.ServerNotification(\n                types.PromptListChangedNotification(\n                    method=\"notifications/prompts/list_changed\",\n                )\n            )\n        )\n\n    async def _handle_incoming(self, req: ServerRequestResponder) -&gt; None:\n        await self._incoming_message_stream_writer.send(req)\n\n    @property\n    def incoming_messages(\n        self,\n    ) -&gt; MemoryObjectReceiveStream[ServerRequestResponder]:\n        return self._incoming_message_stream_reader\n</code></pre>"},{"location":"api/#mcp.ServerSession.check_client_capability","title":"check_client_capability","text":"<pre><code>check_client_capability(\n    capability: ClientCapabilities,\n) -&gt; bool\n</code></pre> <p>Check if the client supports a specific capability.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>def check_client_capability(self, capability: types.ClientCapabilities) -&gt; bool:\n    \"\"\"Check if the client supports a specific capability.\"\"\"\n    if self._client_params is None:\n        return False\n\n    # Get client capabilities from initialization params\n    client_caps = self._client_params.capabilities\n\n    # Check each specified capability in the passed in capability object\n    if capability.roots is not None:\n        if client_caps.roots is None:\n            return False\n        if capability.roots.listChanged and not client_caps.roots.listChanged:\n            return False\n\n    if capability.sampling is not None:\n        if client_caps.sampling is None:\n            return False\n\n    if capability.experimental is not None:\n        if client_caps.experimental is None:\n            return False\n        # Check each experimental capability\n        for exp_key, exp_value in capability.experimental.items():\n            if (\n                exp_key not in client_caps.experimental\n                or client_caps.experimental[exp_key] != exp_value\n            ):\n                return False\n\n    return True\n</code></pre>"},{"location":"api/#mcp.ServerSession.send_log_message","title":"send_log_message  <code>async</code>","text":"<pre><code>send_log_message(\n    level: LoggingLevel,\n    data: Any,\n    logger: str | None = None,\n    related_request_id: RequestId | None = None,\n) -&gt; None\n</code></pre> <p>Send a log message notification.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def send_log_message(\n    self,\n    level: types.LoggingLevel,\n    data: Any,\n    logger: str | None = None,\n    related_request_id: types.RequestId | None = None,\n) -&gt; None:\n    \"\"\"Send a log message notification.\"\"\"\n    await self.send_notification(\n        types.ServerNotification(\n            types.LoggingMessageNotification(\n                method=\"notifications/message\",\n                params=types.LoggingMessageNotificationParams(\n                    level=level,\n                    data=data,\n                    logger=logger,\n                ),\n            )\n        ),\n        related_request_id,\n    )\n</code></pre>"},{"location":"api/#mcp.ServerSession.send_resource_updated","title":"send_resource_updated  <code>async</code>","text":"<pre><code>send_resource_updated(uri: AnyUrl) -&gt; None\n</code></pre> <p>Send a resource updated notification.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def send_resource_updated(self, uri: AnyUrl) -&gt; None:\n    \"\"\"Send a resource updated notification.\"\"\"\n    await self.send_notification(\n        types.ServerNotification(\n            types.ResourceUpdatedNotification(\n                method=\"notifications/resources/updated\",\n                params=types.ResourceUpdatedNotificationParams(uri=uri),\n            )\n        )\n    )\n</code></pre>"},{"location":"api/#mcp.ServerSession.create_message","title":"create_message  <code>async</code>","text":"<pre><code>create_message(\n    messages: list[SamplingMessage],\n    *,\n    max_tokens: int,\n    system_prompt: str | None = None,\n    include_context: IncludeContext | None = None,\n    temperature: float | None = None,\n    stop_sequences: list[str] | None = None,\n    metadata: dict[str, Any] | None = None,\n    model_preferences: ModelPreferences | None = None,\n    related_request_id: RequestId | None = None\n) -&gt; CreateMessageResult\n</code></pre> <p>Send a sampling/create_message request.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def create_message(\n    self,\n    messages: list[types.SamplingMessage],\n    *,\n    max_tokens: int,\n    system_prompt: str | None = None,\n    include_context: types.IncludeContext | None = None,\n    temperature: float | None = None,\n    stop_sequences: list[str] | None = None,\n    metadata: dict[str, Any] | None = None,\n    model_preferences: types.ModelPreferences | None = None,\n    related_request_id: types.RequestId | None = None,\n) -&gt; types.CreateMessageResult:\n    \"\"\"Send a sampling/create_message request.\"\"\"\n    return await self.send_request(\n        request=types.ServerRequest(\n            types.CreateMessageRequest(\n                method=\"sampling/createMessage\",\n                params=types.CreateMessageRequestParams(\n                    messages=messages,\n                    systemPrompt=system_prompt,\n                    includeContext=include_context,\n                    temperature=temperature,\n                    maxTokens=max_tokens,\n                    stopSequences=stop_sequences,\n                    metadata=metadata,\n                    modelPreferences=model_preferences,\n                ),\n            )\n        ),\n        result_type=types.CreateMessageResult,\n        metadata=ServerMessageMetadata(\n            related_request_id=related_request_id,\n        ),\n    )\n</code></pre>"},{"location":"api/#mcp.ServerSession.list_roots","title":"list_roots  <code>async</code>","text":"<pre><code>list_roots() -&gt; ListRootsResult\n</code></pre> <p>Send a roots/list request.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def list_roots(self) -&gt; types.ListRootsResult:\n    \"\"\"Send a roots/list request.\"\"\"\n    return await self.send_request(\n        types.ServerRequest(\n            types.ListRootsRequest(\n                method=\"roots/list\",\n            )\n        ),\n        types.ListRootsResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ServerSession.send_ping","title":"send_ping  <code>async</code>","text":"<pre><code>send_ping() -&gt; EmptyResult\n</code></pre> <p>Send a ping request.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def send_ping(self) -&gt; types.EmptyResult:\n    \"\"\"Send a ping request.\"\"\"\n    return await self.send_request(\n        types.ServerRequest(\n            types.PingRequest(\n                method=\"ping\",\n            )\n        ),\n        types.EmptyResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ServerSession.send_progress_notification","title":"send_progress_notification  <code>async</code>","text":"<pre><code>send_progress_notification(\n    progress_token: str | int,\n    progress: float,\n    total: float | None = None,\n    message: str | None = None,\n    related_request_id: str | None = None,\n) -&gt; None\n</code></pre> <p>Send a progress notification.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def send_progress_notification(\n    self,\n    progress_token: str | int,\n    progress: float,\n    total: float | None = None,\n    message: str | None = None,\n    related_request_id: str | None = None,\n) -&gt; None:\n    \"\"\"Send a progress notification.\"\"\"\n    await self.send_notification(\n        types.ServerNotification(\n            types.ProgressNotification(\n                method=\"notifications/progress\",\n                params=types.ProgressNotificationParams(\n                    progressToken=progress_token,\n                    progress=progress,\n                    total=total,\n                    message=message,\n                ),\n            )\n        ),\n        related_request_id,\n    )\n</code></pre>"},{"location":"api/#mcp.ServerSession.send_resource_list_changed","title":"send_resource_list_changed  <code>async</code>","text":"<pre><code>send_resource_list_changed() -&gt; None\n</code></pre> <p>Send a resource list changed notification.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def send_resource_list_changed(self) -&gt; None:\n    \"\"\"Send a resource list changed notification.\"\"\"\n    await self.send_notification(\n        types.ServerNotification(\n            types.ResourceListChangedNotification(\n                method=\"notifications/resources/list_changed\",\n            )\n        )\n    )\n</code></pre>"},{"location":"api/#mcp.ServerSession.send_tool_list_changed","title":"send_tool_list_changed  <code>async</code>","text":"<pre><code>send_tool_list_changed() -&gt; None\n</code></pre> <p>Send a tool list changed notification.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def send_tool_list_changed(self) -&gt; None:\n    \"\"\"Send a tool list changed notification.\"\"\"\n    await self.send_notification(\n        types.ServerNotification(\n            types.ToolListChangedNotification(\n                method=\"notifications/tools/list_changed\",\n            )\n        )\n    )\n</code></pre>"},{"location":"api/#mcp.ServerSession.send_prompt_list_changed","title":"send_prompt_list_changed  <code>async</code>","text":"<pre><code>send_prompt_list_changed() -&gt; None\n</code></pre> <p>Send a prompt list changed notification.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def send_prompt_list_changed(self) -&gt; None:\n    \"\"\"Send a prompt list changed notification.\"\"\"\n    await self.send_notification(\n        types.ServerNotification(\n            types.PromptListChangedNotification(\n                method=\"notifications/prompts/list_changed\",\n            )\n        )\n    )\n</code></pre>"},{"location":"api/#mcp.stdio_server","title":"stdio_server  <code>async</code>","text":"<pre><code>stdio_server(\n    stdin: AsyncFile[str] | None = None,\n    stdout: AsyncFile[str] | None = None,\n)\n</code></pre> <p>Server transport for stdio: this communicates with an MCP client by reading from the current process' stdin and writing to stdout.</p> Source code in <code>src/mcp/server/stdio.py</code> <pre><code>@asynccontextmanager\nasync def stdio_server(\n    stdin: anyio.AsyncFile[str] | None = None,\n    stdout: anyio.AsyncFile[str] | None = None,\n):\n    \"\"\"\n    Server transport for stdio: this communicates with an MCP client by reading\n    from the current process' stdin and writing to stdout.\n    \"\"\"\n    # Purposely not using context managers for these, as we don't want to close\n    # standard process handles. Encoding of stdin/stdout as text streams on\n    # python is platform-dependent (Windows is particularly problematic), so we\n    # re-wrap the underlying binary stream to ensure UTF-8.\n    if not stdin:\n        stdin = anyio.wrap_file(TextIOWrapper(sys.stdin.buffer, encoding=\"utf-8\"))\n    if not stdout:\n        stdout = anyio.wrap_file(TextIOWrapper(sys.stdout.buffer, encoding=\"utf-8\"))\n\n    read_stream: MemoryObjectReceiveStream[SessionMessage | Exception]\n    read_stream_writer: MemoryObjectSendStream[SessionMessage | Exception]\n\n    write_stream: MemoryObjectSendStream[SessionMessage]\n    write_stream_reader: MemoryObjectReceiveStream[SessionMessage]\n\n    read_stream_writer, read_stream = anyio.create_memory_object_stream(0)\n    write_stream, write_stream_reader = anyio.create_memory_object_stream(0)\n\n    async def stdin_reader():\n        try:\n            async with read_stream_writer:\n                async for line in stdin:\n                    try:\n                        message = types.JSONRPCMessage.model_validate_json(line)\n                    except Exception as exc:\n                        await read_stream_writer.send(exc)\n                        continue\n\n                    session_message = SessionMessage(message)\n                    await read_stream_writer.send(session_message)\n        except anyio.ClosedResourceError:\n            await anyio.lowlevel.checkpoint()\n\n    async def stdout_writer():\n        try:\n            async with write_stream_reader:\n                async for session_message in write_stream_reader:\n                    json = session_message.message.model_dump_json(\n                        by_alias=True, exclude_none=True\n                    )\n                    await stdout.write(json + \"\\n\")\n                    await stdout.flush()\n        except anyio.ClosedResourceError:\n            await anyio.lowlevel.checkpoint()\n\n    async with anyio.create_task_group() as tg:\n        tg.start_soon(stdin_reader)\n        tg.start_soon(stdout_writer)\n        yield read_stream, write_stream\n</code></pre>"},{"location":"api/#mcp.McpError","title":"McpError","text":"<p>               Bases: <code>Exception</code></p> <p>Exception type raised when an error arrives over an MCP connection.</p> Source code in <code>src/mcp/shared/exceptions.py</code> <pre><code>class McpError(Exception):\n    \"\"\"\n    Exception type raised when an error arrives over an MCP connection.\n    \"\"\"\n\n    error: ErrorData\n\n    def __init__(self, error: ErrorData):\n        \"\"\"Initialize McpError.\"\"\"\n        super().__init__(error.message)\n        self.error = error\n</code></pre>"},{"location":"api/#mcp.McpError.__init__","title":"__init__","text":"<pre><code>__init__(error: ErrorData)\n</code></pre> <p>Initialize McpError.</p> Source code in <code>src/mcp/shared/exceptions.py</code> <pre><code>def __init__(self, error: ErrorData):\n    \"\"\"Initialize McpError.\"\"\"\n    super().__init__(error.message)\n    self.error = error\n</code></pre>"},{"location":"api/#mcp.CallToolRequest","title":"CallToolRequest","text":"<p>               Bases: <code>Request[CallToolRequestParams, Literal['tools/call']]</code></p> <p>Used by the client to invoke a tool provided by the server.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class CallToolRequest(Request[CallToolRequestParams, Literal[\"tools/call\"]]):\n    \"\"\"Used by the client to invoke a tool provided by the server.\"\"\"\n\n    method: Literal[\"tools/call\"]\n    params: CallToolRequestParams\n</code></pre>"},{"location":"api/#mcp.ClientCapabilities","title":"ClientCapabilities","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capabilities a client may support.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ClientCapabilities(BaseModel):\n    \"\"\"Capabilities a client may support.\"\"\"\n\n    experimental: dict[str, dict[str, Any]] | None = None\n    \"\"\"Experimental, non-standard capabilities that the client supports.\"\"\"\n    sampling: SamplingCapability | None = None\n    \"\"\"Present if the client supports sampling from an LLM.\"\"\"\n    roots: RootsCapability | None = None\n    \"\"\"Present if the client supports listing roots.\"\"\"\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.ClientCapabilities.experimental","title":"experimental  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>experimental: dict[str, dict[str, Any]] | None = None\n</code></pre> <p>Experimental, non-standard capabilities that the client supports.</p>"},{"location":"api/#mcp.ClientCapabilities.sampling","title":"sampling  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sampling: SamplingCapability | None = None\n</code></pre> <p>Present if the client supports sampling from an LLM.</p>"},{"location":"api/#mcp.ClientCapabilities.roots","title":"roots  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>roots: RootsCapability | None = None\n</code></pre> <p>Present if the client supports listing roots.</p>"},{"location":"api/#mcp.CompleteRequest","title":"CompleteRequest","text":"<p>               Bases: <code>Request[CompleteRequestParams, Literal['completion/complete']]</code></p> <p>A request from the client to the server, to ask for completion options.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class CompleteRequest(Request[CompleteRequestParams, Literal[\"completion/complete\"]]):\n    \"\"\"A request from the client to the server, to ask for completion options.\"\"\"\n\n    method: Literal[\"completion/complete\"]\n    params: CompleteRequestParams\n</code></pre>"},{"location":"api/#mcp.CreateMessageRequest","title":"CreateMessageRequest","text":"<p>               Bases: <code>Request[CreateMessageRequestParams, Literal['sampling/createMessage']]</code></p> <p>A request from the server to sample an LLM via the client.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class CreateMessageRequest(\n    Request[CreateMessageRequestParams, Literal[\"sampling/createMessage\"]]\n):\n    \"\"\"A request from the server to sample an LLM via the client.\"\"\"\n\n    method: Literal[\"sampling/createMessage\"]\n    params: CreateMessageRequestParams\n</code></pre>"},{"location":"api/#mcp.CreateMessageResult","title":"CreateMessageResult","text":"<p>               Bases: <code>Result</code></p> <p>The client's response to a sampling/create_message request from the server.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class CreateMessageResult(Result):\n    \"\"\"The client's response to a sampling/create_message request from the server.\"\"\"\n\n    role: Role\n    content: TextContent | ImageContent\n    model: str\n    \"\"\"The name of the model that generated the message.\"\"\"\n    stopReason: StopReason | None = None\n    \"\"\"The reason why sampling stopped, if known.\"\"\"\n</code></pre>"},{"location":"api/#mcp.CreateMessageResult.model","title":"model  <code>instance-attribute</code>","text":"<pre><code>model: str\n</code></pre> <p>The name of the model that generated the message.</p>"},{"location":"api/#mcp.CreateMessageResult.stopReason","title":"stopReason  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stopReason: StopReason | None = None\n</code></pre> <p>The reason why sampling stopped, if known.</p>"},{"location":"api/#mcp.ErrorData","title":"ErrorData","text":"<p>               Bases: <code>BaseModel</code></p> <p>Error information for JSON-RPC error responses.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ErrorData(BaseModel):\n    \"\"\"Error information for JSON-RPC error responses.\"\"\"\n\n    code: int\n    \"\"\"The error type that occurred.\"\"\"\n\n    message: str\n    \"\"\"\n    A short description of the error. The message SHOULD be limited to a concise single\n    sentence.\n    \"\"\"\n\n    data: Any | None = None\n    \"\"\"\n    Additional information about the error. The value of this member is defined by the\n    sender (e.g. detailed error information, nested errors etc.).\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.ErrorData.code","title":"code  <code>instance-attribute</code>","text":"<pre><code>code: int\n</code></pre> <p>The error type that occurred.</p>"},{"location":"api/#mcp.ErrorData.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message: str\n</code></pre> <p>A short description of the error. The message SHOULD be limited to a concise single sentence.</p>"},{"location":"api/#mcp.ErrorData.data","title":"data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data: Any | None = None\n</code></pre> <p>Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).</p>"},{"location":"api/#mcp.GetPromptRequest","title":"GetPromptRequest","text":"<p>               Bases: <code>Request[GetPromptRequestParams, Literal['prompts/get']]</code></p> <p>Used by the client to get a prompt provided by the server.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class GetPromptRequest(Request[GetPromptRequestParams, Literal[\"prompts/get\"]]):\n    \"\"\"Used by the client to get a prompt provided by the server.\"\"\"\n\n    method: Literal[\"prompts/get\"]\n    params: GetPromptRequestParams\n</code></pre>"},{"location":"api/#mcp.GetPromptResult","title":"GetPromptResult","text":"<p>               Bases: <code>Result</code></p> <p>The server's response to a prompts/get request from the client.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class GetPromptResult(Result):\n    \"\"\"The server's response to a prompts/get request from the client.\"\"\"\n\n    description: str | None = None\n    \"\"\"An optional description for the prompt.\"\"\"\n    messages: list[PromptMessage]\n</code></pre>"},{"location":"api/#mcp.GetPromptResult.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | None = None\n</code></pre> <p>An optional description for the prompt.</p>"},{"location":"api/#mcp.Implementation","title":"Implementation","text":"<p>               Bases: <code>BaseModel</code></p> <p>Describes the name and version of an MCP implementation.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class Implementation(BaseModel):\n    \"\"\"Describes the name and version of an MCP implementation.\"\"\"\n\n    name: str\n    version: str\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.InitializedNotification","title":"InitializedNotification","text":"<p>               Bases: <code>Notification[NotificationParams | None, Literal['notifications/initialized']]</code></p> <p>This notification is sent from the client to the server after initialization has finished.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class InitializedNotification(\n    Notification[NotificationParams | None, Literal[\"notifications/initialized\"]]\n):\n    \"\"\"\n    This notification is sent from the client to the server after initialization has\n    finished.\n    \"\"\"\n\n    method: Literal[\"notifications/initialized\"]\n    params: NotificationParams | None = None\n</code></pre>"},{"location":"api/#mcp.InitializeRequest","title":"InitializeRequest","text":"<p>               Bases: <code>Request[InitializeRequestParams, Literal['initialize']]</code></p> <p>This request is sent from the client to the server when it first connects, asking it to begin initialization.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class InitializeRequest(Request[InitializeRequestParams, Literal[\"initialize\"]]):\n    \"\"\"\n    This request is sent from the client to the server when it first connects, asking it\n    to begin initialization.\n    \"\"\"\n\n    method: Literal[\"initialize\"]\n    params: InitializeRequestParams\n</code></pre>"},{"location":"api/#mcp.InitializeResult","title":"InitializeResult","text":"<p>               Bases: <code>Result</code></p> <p>After receiving an initialize request from the client, the server sends this.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class InitializeResult(Result):\n    \"\"\"After receiving an initialize request from the client, the server sends this.\"\"\"\n\n    protocolVersion: str | int\n    \"\"\"The version of the Model Context Protocol that the server wants to use.\"\"\"\n    capabilities: ServerCapabilities\n    serverInfo: Implementation\n    instructions: str | None = None\n    \"\"\"Instructions describing how to use the server and its features.\"\"\"\n</code></pre>"},{"location":"api/#mcp.InitializeResult.protocolVersion","title":"protocolVersion  <code>instance-attribute</code>","text":"<pre><code>protocolVersion: str | int\n</code></pre> <p>The version of the Model Context Protocol that the server wants to use.</p>"},{"location":"api/#mcp.InitializeResult.instructions","title":"instructions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>instructions: str | None = None\n</code></pre> <p>Instructions describing how to use the server and its features.</p>"},{"location":"api/#mcp.JSONRPCError","title":"JSONRPCError","text":"<p>               Bases: <code>BaseModel</code></p> <p>A response to a request that indicates an error occurred.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class JSONRPCError(BaseModel):\n    \"\"\"A response to a request that indicates an error occurred.\"\"\"\n\n    jsonrpc: Literal[\"2.0\"]\n    id: str | int\n    error: ErrorData\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.JSONRPCRequest","title":"JSONRPCRequest","text":"<p>               Bases: <code>Request[dict[str, Any] | None, str]</code></p> <p>A request that expects a response.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class JSONRPCRequest(Request[dict[str, Any] | None, str]):\n    \"\"\"A request that expects a response.\"\"\"\n\n    jsonrpc: Literal[\"2.0\"]\n    id: RequestId\n    method: str\n    params: dict[str, Any] | None = None\n</code></pre>"},{"location":"api/#mcp.JSONRPCResponse","title":"JSONRPCResponse","text":"<p>               Bases: <code>BaseModel</code></p> <p>A successful (non-error) response to a request.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class JSONRPCResponse(BaseModel):\n    \"\"\"A successful (non-error) response to a request.\"\"\"\n\n    jsonrpc: Literal[\"2.0\"]\n    id: RequestId\n    result: dict[str, Any]\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.ListPromptsRequest","title":"ListPromptsRequest","text":"<p>               Bases: <code>PaginatedRequest[RequestParams | None, Literal['prompts/list']]</code></p> <p>Sent from the client to request a list of prompts and prompt templates.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ListPromptsRequest(\n    PaginatedRequest[RequestParams | None, Literal[\"prompts/list\"]]\n):\n    \"\"\"Sent from the client to request a list of prompts and prompt templates.\"\"\"\n\n    method: Literal[\"prompts/list\"]\n    params: RequestParams | None = None\n</code></pre>"},{"location":"api/#mcp.ListPromptsResult","title":"ListPromptsResult","text":"<p>               Bases: <code>PaginatedResult</code></p> <p>The server's response to a prompts/list request from the client.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ListPromptsResult(PaginatedResult):\n    \"\"\"The server's response to a prompts/list request from the client.\"\"\"\n\n    prompts: list[Prompt]\n</code></pre>"},{"location":"api/#mcp.ListResourcesRequest","title":"ListResourcesRequest","text":"<p>               Bases: <code>PaginatedRequest[RequestParams | None, Literal['resources/list']]</code></p> <p>Sent from the client to request a list of resources the server has.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ListResourcesRequest(\n    PaginatedRequest[RequestParams | None, Literal[\"resources/list\"]]\n):\n    \"\"\"Sent from the client to request a list of resources the server has.\"\"\"\n\n    method: Literal[\"resources/list\"]\n    params: RequestParams | None = None\n</code></pre>"},{"location":"api/#mcp.ListResourcesResult","title":"ListResourcesResult","text":"<p>               Bases: <code>PaginatedResult</code></p> <p>The server's response to a resources/list request from the client.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ListResourcesResult(PaginatedResult):\n    \"\"\"The server's response to a resources/list request from the client.\"\"\"\n\n    resources: list[Resource]\n</code></pre>"},{"location":"api/#mcp.ListToolsResult","title":"ListToolsResult","text":"<p>               Bases: <code>PaginatedResult</code></p> <p>The server's response to a tools/list request from the client.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ListToolsResult(PaginatedResult):\n    \"\"\"The server's response to a tools/list request from the client.\"\"\"\n\n    tools: list[Tool]\n</code></pre>"},{"location":"api/#mcp.LoggingMessageNotification","title":"LoggingMessageNotification","text":"<p>               Bases: <code>Notification[LoggingMessageNotificationParams, Literal['notifications/message']]</code></p> <p>Notification of a log message passed from server to client.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class LoggingMessageNotification(\n    Notification[LoggingMessageNotificationParams, Literal[\"notifications/message\"]]\n):\n    \"\"\"Notification of a log message passed from server to client.\"\"\"\n\n    method: Literal[\"notifications/message\"]\n    params: LoggingMessageNotificationParams\n</code></pre>"},{"location":"api/#mcp.Notification","title":"Notification","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[NotificationParamsT, MethodT]</code></p> <p>Base class for JSON-RPC notifications.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class Notification(BaseModel, Generic[NotificationParamsT, MethodT]):\n    \"\"\"Base class for JSON-RPC notifications.\"\"\"\n\n    method: MethodT\n    params: NotificationParamsT\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.PingRequest","title":"PingRequest","text":"<p>               Bases: <code>Request[RequestParams | None, Literal['ping']]</code></p> <p>A ping, issued by either the server or the client, to check that the other party is still alive.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class PingRequest(Request[RequestParams | None, Literal[\"ping\"]]):\n    \"\"\"\n    A ping, issued by either the server or the client, to check that the other party is\n    still alive.\n    \"\"\"\n\n    method: Literal[\"ping\"]\n    params: RequestParams | None = None\n</code></pre>"},{"location":"api/#mcp.ProgressNotification","title":"ProgressNotification","text":"<p>               Bases: <code>Notification[ProgressNotificationParams, Literal['notifications/progress']]</code></p> <p>An out-of-band notification used to inform the receiver of a progress update for a long-running request.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ProgressNotification(\n    Notification[ProgressNotificationParams, Literal[\"notifications/progress\"]]\n):\n    \"\"\"\n    An out-of-band notification used to inform the receiver of a progress update for a\n    long-running request.\n    \"\"\"\n\n    method: Literal[\"notifications/progress\"]\n    params: ProgressNotificationParams\n</code></pre>"},{"location":"api/#mcp.PromptsCapability","title":"PromptsCapability","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capability for prompts operations.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class PromptsCapability(BaseModel):\n    \"\"\"Capability for prompts operations.\"\"\"\n\n    listChanged: bool | None = None\n    \"\"\"Whether this server supports notifications for changes to the prompt list.\"\"\"\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.PromptsCapability.listChanged","title":"listChanged  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>listChanged: bool | None = None\n</code></pre> <p>Whether this server supports notifications for changes to the prompt list.</p>"},{"location":"api/#mcp.ReadResourceRequest","title":"ReadResourceRequest","text":"<p>               Bases: <code>Request[ReadResourceRequestParams, Literal['resources/read']]</code></p> <p>Sent from the client to the server, to read a specific resource URI.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ReadResourceRequest(\n    Request[ReadResourceRequestParams, Literal[\"resources/read\"]]\n):\n    \"\"\"Sent from the client to the server, to read a specific resource URI.\"\"\"\n\n    method: Literal[\"resources/read\"]\n    params: ReadResourceRequestParams\n</code></pre>"},{"location":"api/#mcp.ReadResourceResult","title":"ReadResourceResult","text":"<p>               Bases: <code>Result</code></p> <p>The server's response to a resources/read request from the client.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ReadResourceResult(Result):\n    \"\"\"The server's response to a resources/read request from the client.\"\"\"\n\n    contents: list[TextResourceContents | BlobResourceContents]\n</code></pre>"},{"location":"api/#mcp.Resource","title":"Resource","text":"<p>               Bases: <code>BaseModel</code></p> <p>A known resource that the server is capable of reading.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class Resource(BaseModel):\n    \"\"\"A known resource that the server is capable of reading.\"\"\"\n\n    uri: Annotated[AnyUrl, UrlConstraints(host_required=False)]\n    \"\"\"The URI of this resource.\"\"\"\n    name: str\n    \"\"\"A human-readable name for this resource.\"\"\"\n    description: str | None = None\n    \"\"\"A description of what this resource represents.\"\"\"\n    mimeType: str | None = None\n    \"\"\"The MIME type of this resource, if known.\"\"\"\n    size: int | None = None\n    \"\"\"\n    The size of the raw resource content, in bytes (i.e., before base64 encoding\n    or any tokenization), if known.\n\n    This can be used by Hosts to display file sizes and estimate context window usage.\n    \"\"\"\n    annotations: Annotations | None = None\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.Resource.uri","title":"uri  <code>instance-attribute</code>","text":"<pre><code>uri: Annotated[AnyUrl, UrlConstraints(host_required=False)]\n</code></pre> <p>The URI of this resource.</p>"},{"location":"api/#mcp.Resource.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>A human-readable name for this resource.</p>"},{"location":"api/#mcp.Resource.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | None = None\n</code></pre> <p>A description of what this resource represents.</p>"},{"location":"api/#mcp.Resource.mimeType","title":"mimeType  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mimeType: str | None = None\n</code></pre> <p>The MIME type of this resource, if known.</p>"},{"location":"api/#mcp.Resource.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>size: int | None = None\n</code></pre> <p>The size of the raw resource content, in bytes (i.e., before base64 encoding or any tokenization), if known.</p> <p>This can be used by Hosts to display file sizes and estimate context window usage.</p>"},{"location":"api/#mcp.ResourcesCapability","title":"ResourcesCapability","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capability for resources operations.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ResourcesCapability(BaseModel):\n    \"\"\"Capability for resources operations.\"\"\"\n\n    subscribe: bool | None = None\n    \"\"\"Whether this server supports subscribing to resource updates.\"\"\"\n    listChanged: bool | None = None\n    \"\"\"Whether this server supports notifications for changes to the resource list.\"\"\"\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.ResourcesCapability.subscribe","title":"subscribe  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>subscribe: bool | None = None\n</code></pre> <p>Whether this server supports subscribing to resource updates.</p>"},{"location":"api/#mcp.ResourcesCapability.listChanged","title":"listChanged  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>listChanged: bool | None = None\n</code></pre> <p>Whether this server supports notifications for changes to the resource list.</p>"},{"location":"api/#mcp.ResourceUpdatedNotification","title":"ResourceUpdatedNotification","text":"<p>               Bases: <code>Notification[ResourceUpdatedNotificationParams, Literal['notifications/resources/updated']]</code></p> <p>A notification from the server to the client, informing it that a resource has changed and may need to be read again.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ResourceUpdatedNotification(\n    Notification[\n        ResourceUpdatedNotificationParams, Literal[\"notifications/resources/updated\"]\n    ]\n):\n    \"\"\"\n    A notification from the server to the client, informing it that a resource has\n    changed and may need to be read again.\n    \"\"\"\n\n    method: Literal[\"notifications/resources/updated\"]\n    params: ResourceUpdatedNotificationParams\n</code></pre>"},{"location":"api/#mcp.RootsCapability","title":"RootsCapability","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capability for root operations.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class RootsCapability(BaseModel):\n    \"\"\"Capability for root operations.\"\"\"\n\n    listChanged: bool | None = None\n    \"\"\"Whether the client supports notifications for changes to the roots list.\"\"\"\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.RootsCapability.listChanged","title":"listChanged  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>listChanged: bool | None = None\n</code></pre> <p>Whether the client supports notifications for changes to the roots list.</p>"},{"location":"api/#mcp.SamplingMessage","title":"SamplingMessage","text":"<p>               Bases: <code>BaseModel</code></p> <p>Describes a message issued to or received from an LLM API.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class SamplingMessage(BaseModel):\n    \"\"\"Describes a message issued to or received from an LLM API.\"\"\"\n\n    role: Role\n    content: TextContent | ImageContent\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.ServerCapabilities","title":"ServerCapabilities","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capabilities that a server may support.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ServerCapabilities(BaseModel):\n    \"\"\"Capabilities that a server may support.\"\"\"\n\n    experimental: dict[str, dict[str, Any]] | None = None\n    \"\"\"Experimental, non-standard capabilities that the server supports.\"\"\"\n    logging: LoggingCapability | None = None\n    \"\"\"Present if the server supports sending log messages to the client.\"\"\"\n    prompts: PromptsCapability | None = None\n    \"\"\"Present if the server offers any prompt templates.\"\"\"\n    resources: ResourcesCapability | None = None\n    \"\"\"Present if the server offers any resources to read.\"\"\"\n    tools: ToolsCapability | None = None\n    \"\"\"Present if the server offers any tools to call.\"\"\"\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.ServerCapabilities.experimental","title":"experimental  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>experimental: dict[str, dict[str, Any]] | None = None\n</code></pre> <p>Experimental, non-standard capabilities that the server supports.</p>"},{"location":"api/#mcp.ServerCapabilities.logging","title":"logging  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>logging: LoggingCapability | None = None\n</code></pre> <p>Present if the server supports sending log messages to the client.</p>"},{"location":"api/#mcp.ServerCapabilities.prompts","title":"prompts  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prompts: PromptsCapability | None = None\n</code></pre> <p>Present if the server offers any prompt templates.</p>"},{"location":"api/#mcp.ServerCapabilities.resources","title":"resources  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resources: ResourcesCapability | None = None\n</code></pre> <p>Present if the server offers any resources to read.</p>"},{"location":"api/#mcp.ServerCapabilities.tools","title":"tools  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tools: ToolsCapability | None = None\n</code></pre> <p>Present if the server offers any tools to call.</p>"},{"location":"api/#mcp.SetLevelRequest","title":"SetLevelRequest","text":"<p>               Bases: <code>Request[SetLevelRequestParams, Literal['logging/setLevel']]</code></p> <p>A request from the client to the server, to enable or adjust logging.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class SetLevelRequest(Request[SetLevelRequestParams, Literal[\"logging/setLevel\"]]):\n    \"\"\"A request from the client to the server, to enable or adjust logging.\"\"\"\n\n    method: Literal[\"logging/setLevel\"]\n    params: SetLevelRequestParams\n</code></pre>"},{"location":"api/#mcp.SubscribeRequest","title":"SubscribeRequest","text":"<p>               Bases: <code>Request[SubscribeRequestParams, Literal['resources/subscribe']]</code></p> <p>Sent from the client to request resources/updated notifications from the server whenever a particular resource changes.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class SubscribeRequest(Request[SubscribeRequestParams, Literal[\"resources/subscribe\"]]):\n    \"\"\"\n    Sent from the client to request resources/updated notifications from the server\n    whenever a particular resource changes.\n    \"\"\"\n\n    method: Literal[\"resources/subscribe\"]\n    params: SubscribeRequestParams\n</code></pre>"},{"location":"api/#mcp.Tool","title":"Tool","text":"<p>               Bases: <code>BaseModel</code></p> <p>Definition for a tool the client can call.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class Tool(BaseModel):\n    \"\"\"Definition for a tool the client can call.\"\"\"\n\n    name: str\n    \"\"\"The name of the tool.\"\"\"\n    description: str | None = None\n    \"\"\"A human-readable description of the tool.\"\"\"\n    inputSchema: dict[str, Any]\n    \"\"\"A JSON Schema object defining the expected parameters for the tool.\"\"\"\n    annotations: ToolAnnotations | None = None\n    \"\"\"Optional additional tool information.\"\"\"\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.Tool.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the tool.</p>"},{"location":"api/#mcp.Tool.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | None = None\n</code></pre> <p>A human-readable description of the tool.</p>"},{"location":"api/#mcp.Tool.inputSchema","title":"inputSchema  <code>instance-attribute</code>","text":"<pre><code>inputSchema: dict[str, Any]\n</code></pre> <p>A JSON Schema object defining the expected parameters for the tool.</p>"},{"location":"api/#mcp.Tool.annotations","title":"annotations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>annotations: ToolAnnotations | None = None\n</code></pre> <p>Optional additional tool information.</p>"},{"location":"api/#mcp.ToolsCapability","title":"ToolsCapability","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capability for tools operations.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ToolsCapability(BaseModel):\n    \"\"\"Capability for tools operations.\"\"\"\n\n    listChanged: bool | None = None\n    \"\"\"Whether this server supports notifications for changes to the tool list.\"\"\"\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.ToolsCapability.listChanged","title":"listChanged  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>listChanged: bool | None = None\n</code></pre> <p>Whether this server supports notifications for changes to the tool list.</p>"},{"location":"api/#mcp.UnsubscribeRequest","title":"UnsubscribeRequest","text":"<p>               Bases: <code>Request[UnsubscribeRequestParams, Literal['resources/unsubscribe']]</code></p> <p>Sent from the client to request cancellation of resources/updated notifications from the server.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class UnsubscribeRequest(\n    Request[UnsubscribeRequestParams, Literal[\"resources/unsubscribe\"]]\n):\n    \"\"\"\n    Sent from the client to request cancellation of resources/updated notifications from\n    the server.\n    \"\"\"\n\n    method: Literal[\"resources/unsubscribe\"]\n    params: UnsubscribeRequestParams\n</code></pre>"},{"location":"attack-prevention/","title":"Attack Prevention","text":"<p>ETDI provides robust protection against advanced AI security threats, including tool poisoning, rug poisoning, and unauthorized tool access. This page summarizes the core attack prevention strategies and how to implement them.</p>"},{"location":"attack-prevention/#tool-poisoning-prevention","title":"Tool Poisoning Prevention","text":"<p>Tool poisoning occurs when a malicious actor introduces or replaces a tool with a compromised version. ETDI prevents this via:</p> <ul> <li>Cryptographic Signatures: All tools are signed and verified at registration and invocation. See Tool Poisoning Demo for details.</li> <li>Audit Logs for Monitoring: Comprehensive audit logs capture tool activity, which can be fed into external monitoring systems to detect anomalous behavior and policy violations.</li> <li>Approval Workflow: Users must explicitly approve new or changed tools before use.</li> </ul>"},{"location":"attack-prevention/#example-secure-tool-registration","title":"Example: Secure Tool Registration","text":"<pre><code>@server.tool(\"secure_file_read\", require_signature=True)\nasync def secure_file_read(path: str) -&gt; str:\n    # Implementation with cryptographic verification\n    ...\n</code></pre>"},{"location":"attack-prevention/#rug-poisoning-protection","title":"Rug Poisoning Protection","text":"<p>Rug poisoning (\"rug pull\") is when a tool is swapped or modified after initial approval. ETDI detects and blocks this via:</p> <ul> <li>Immutable Versioning: Every tool version is cryptographically hashed and tracked.</li> <li>Change Detection: Any change to code, permissions, or metadata triggers reapproval.</li> <li>Audit Trails: All tool changes and approvals are logged for forensics.</li> </ul> <p>Details on how ETDI mitigates this can be found in Rug Poisoning Protection.</p>"},{"location":"attack-prevention/#example-versioned-tool-approval","title":"Example: Versioned Tool Approval","text":"<pre><code># User approves tool version 1.0\nawait client.approve_tool(tool_id, version=\"1.0\")\n\n# If the tool changes (hash mismatch), approval is revoked until reapproved by the user.\n</code></pre>"},{"location":"attack-prevention/#call-stack-security","title":"Call Stack Security","text":"<p>Call stack security is crucial for preventing privilege escalation and unauthorized tool chaining, ensuring that a sequence of tool calls doesn't lead to unintended capabilities or data access.</p> <p>ETDI implements call stack security through several mechanisms:</p> <ul> <li> <p>Maximum Call Depth: Defines how many levels deep a tool invocation chain can go. This prevents runaway recursive calls or overly complex interactions that might obscure malicious activity or lead to denial-of-service.     <pre><code># Part of SecurityPolicy or individual tool definition\n# server = SecureServer(security_policy=SecurityPolicy(max_call_depth=5))\n@server.tool(\"my_tool\", etdi_max_call_depth=3)\nasync def my_tool_impl(): ...\n</code></pre></p> </li> <li> <p>Allowed/Blocked Callees: Tool definitions can specify which other tools they are explicitly allowed to call, or which ones they are explicitly forbidden from calling. This creates a more predictable and constrained interaction graph.     <pre><code># Part of SecurityPolicy or individual tool definition\n# policy = SecurityPolicy(allowed_callees={\"tool_a\": [\"tool_b\"]})\n@server.tool(\"tool_a\", etdi_allowed_callees=[\"tool_b\", \"tool_c\"])\nasync def tool_a_impl(): ...\n\n@server.tool(\"sensitive_tool\", etdi_blocked_callees=[\"network_tool\", \"external_api_tool\"])\nasync def sensitive_tool_impl(): ...\n</code></pre></p> </li> <li> <p>Caller/Callee Authorization: Beyond just allowed/blocked lists, ETDI can enforce mutual authorization. This means not only must <code>tool_A</code> be allowed to call <code>tool_B</code>, but <code>tool_B</code> must also be configured to accept calls from <code>tool_A</code>. This is typically managed through permission and scope checks tied to the identities of the tools themselves (if they have their own service identities) or the user context propagating the call.</p> </li> <li> <p>Verification: The ETDI client and/or server-side middleware inspects the call stack at each invocation. If a call violates any of these constraints (e.g., exceeds max depth, calls a blocked tool, or lacks authorization), the invocation is rejected before the tool code executes.</p> </li> </ul> <p>These features collectively ensure that tool interactions are confined to well-defined boundaries, significantly reducing the attack surface.</p> <p>Refer to example scripts like <code>protocol_call_stack_example.py</code> and <code>caller_callee_authorization_example.py</code> in the Examples &amp; Demos section for practical implementations.</p>"},{"location":"attack-prevention/#real-world-attack-scenarios","title":"Real-World Attack Scenarios","text":"<ul> <li>Tool Poisoning Demo: See the detailed Tool Poisoning Prevention page and its associated demo scripts in <code>examples/etdi/tool_poisoning_demo/</code>.</li> <li>Rug Poisoning Detection: The framework automatically detects and blocks unauthorized tool changes as detailed in Rug Poisoning Protection.</li> </ul>"},{"location":"attack-prevention/#best-practices","title":"Best Practices","text":"<ul> <li>Always require tool signatures in production.</li> <li>Regularly audit tool approval and change logs.</li> <li>Use strict call chain policies (max depth, allowed/blocked callees) for sensitive operations. </li> </ul>"},{"location":"etdi-concepts/","title":"Enhanced Tool Definition Interface (ETDI): A Security Fortification for the Model Context Protocol","text":""},{"location":"etdi-concepts/#executive-summary","title":"Executive Summary","text":"<p>The Model Context Protocol (MCP) is pivotal in standardizing interactions between AI applications and Large Language Models (LLMs), enabling rich, context-aware experiences by integrating external tools and data. However, the current MCP specification presents significant security vulnerabilities, primarily Tool Poisoning and Rug Pull attacks, which can lead to unauthorized data access, manipulation, and erosion of user trust. This design document meticulously analyzes these vulnerabilities within the standard MCP operational flow. It then introduces the Enhanced Tool Definition Interface (ETDI), a robust security layer designed to mitigate these threats by incorporating cryptographic identity, immutable versioned definitions, and explicit permissioning. Furthermore, this document proposes an advanced ETDI implementation leveraging OAuth 2.0, offering standardized, fine-grained, and centrally managed security controls. The adoption of ETDI aims to significantly bolster the security posture of MCP-enabled ecosystems, ensuring safer and more reliable AI-driven interactions.</p>"},{"location":"etdi-concepts/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction: The Imperative for Secure MCP</li> <li>Understanding the MCP Ecosystem: Architecture Overview</li> <li>Operational Dynamics: The Standard MCP Flow<ul> <li>Initialization and Discovery Phase</li> <li>Tool Invocation and Usage Phase</li> </ul> </li> <li>Critical Security Vulnerabilities in MCP<ul> <li>Attack Vector 1: Tool Poisoning<ul> <li>Definition and Mechanism</li> <li>Vulnerability Analysis</li> <li>Illustrative Attack Scenario</li> </ul> </li> <li>Attack Vector 2: Rug Pull Attacks<ul> <li>Definition and Mechanism</li> <li>Vulnerability Analysis</li> <li>Illustrative Attack Scenario</li> </ul> </li> </ul> </li> <li>ETDI: Fortifying MCP with an Enhanced Tool Definition Interface<ul> <li>Foundational Security Principles of ETDI</li> <li>ETDI Countermeasures: Thwarting Tool Poisoning</li> <li>ETDI Countermeasures: Preventing Rug Pulls</li> </ul> </li> <li>Advancing Security with OAuth-Enhanced ETDI<ul> <li>Architectural Integration of OAuth 2.0</li> <li>Reinforced Protection Flow with OAuth<ul> <li>OAuth-Enhanced Tool Poisoning Defense</li> <li>OAuth-Enhanced Rug Pull Defense</li> </ul> </li> <li>Key Advantages of OAuth Integration</li> </ul> </li> <li>Strategic Implementation Considerations for ETDI<ul> <li>Establishing Verifiable Trust Chains</li> <li>Robust Version Control and Immutability</li> <li>Granular and Explicit Permission Management</li> <li>Assessing and Mitigating Performance Overhead</li> <li>Ensuring Backward Compatibility and Adoption Pathways</li> </ul> </li> <li>Conclusion</li> <li>References</li> </ol>"},{"location":"etdi-concepts/#1-introduction-the-imperative-for-secure-mcp","title":"1. Introduction: The Imperative for Secure MCP","text":"<p>The Model Context Protocol (MCP) represents a significant step towards standardizing how AI applications, particularly those leveraging Large Language Models (LLMs), are provided with dynamic, real-world context. By facilitating seamless integration with external tools, diverse data sources, and auxiliary systems, MCP empowers LLMs to perform complex tasks, access timely information, and offer more relevant and powerful interactions. However, the inherent openness and extensibility of the current MCP specification, while fostering innovation, inadvertently introduce critical security vulnerabilities. The absence of robust mechanisms to verify tool authenticity and integrity exposes users and systems to sophisticated tool-based attacks, such as Tool Poisoning and Rug Pulls. These attacks can lead to severe consequences, including sensitive data exfiltration, unauthorized system actions, and a significant degradation of user trust in AI applications.</p> <p>This document addresses these pressing security concerns by introducing the Enhanced Tool Definition Interface (ETDI). ETDI is conceived as a security enhancement layer, meticulously designed to integrate with the existing MCP framework. It aims to provide verifiable trust and integrity for tools without fundamentally altering the core protocol, thereby preserving its flexibility while addressing its security shortcomings. By focusing on cryptographic verification and explicit consent, ETDI offers a pragmatic and effective solution to safeguard the MCP ecosystem.</p>"},{"location":"etdi-concepts/#2-understanding-the-mcp-ecosystem-architecture-overview","title":"2. Understanding the MCP Ecosystem: Architecture Overview","text":"<p>MCP operates on a distributed client-server model, fostering interaction between various entities to provide LLMs with the necessary context and capabilities. The key components include:</p> <ul> <li>Host Applications: These are the primary interfaces for users, such as AI-powered desktop applications (e.g., Claude Desktop), integrated development environments (IDEs) with AI extensions, or specialized AI-driven platforms. They orchestrate the interaction between the user, the LLM, and MCP components.</li> <li>MCP Clients: Embedded within Host Applications, these software components are responsible for discovering, managing connections to, and interacting with MCP Servers. They act as intermediaries, translating requests and responses between the Host Application and the MCP Servers.</li> <li>MCP Servers: These are dedicated programs or services that expose specific capabilities to MCP Clients. These capabilities can range from simple utility functions to complex data processing services. Each server manages a set of tools, resources, or prompts.</li> <li>Tools: These are discrete functions or services that an LLM can invoke via an MCP Server to perform specific actions (e.g., execute code, fetch data from an API, perform calculations). Tools are the active components that extend the LLM's capabilities.</li> <li>Resources: These represent data sources or information repositories that an LLM can access for contextual understanding or to inform its responses (e.g., a knowledge base, a user's document, a database).</li> <li>Prompts: These are pre-defined templates or instructions that guide the LLM in utilizing tools or resources effectively and for specific tasks, ensuring optimal and consistent performance.</li> </ul> <p><pre><code>flowchart LR\n    User([User])\n    Host[Host Application]\n    Client[MCP Client]\n    LLM[Large Language Model]\n    ServerA[MCP Server A]\n    ServerB[MCP Server B]\n    ToolA[Tool A]\n    ToolB[Tool B]\n\n    User &lt;--&gt; Host\n    Host &lt;--&gt; Client\n    Host &lt;--&gt; LLM\n    Client &lt;--&gt; ServerA\n    Client &lt;--&gt; ServerB\n    ServerA &lt;--&gt; ToolA\n    ServerB &lt;--&gt; ToolB</code></pre> Figure 1: High-Level MCP Architecture, illustrating the interaction between the user, host application, MCP client, LLM, and various MCP servers providing tools.</p>"},{"location":"etdi-concepts/#3-operational-dynamics-the-standard-mcp-flow","title":"3. Operational Dynamics: The Standard MCP Flow","text":"<p>The Model Context Protocol facilitates interactions through a sequence of defined steps, from initialization to tool execution.</p>"},{"location":"etdi-concepts/#initialization-and-discovery-phase","title":"Initialization and Discovery Phase","text":"<p>This phase establishes the connection and awareness between MCP Clients and Servers.</p> <p>The Model Context Protocol operates through a series of well-defined interactions:</p> <pre><code>sequenceDiagram\n    participant User\n    participant Host as Host Application\n    participant Client as MCP Client\n    participant Server as MCP Server\n    participant Tool\n\n    User-&gt;&gt;Host: Launch application\n    Host-&gt;&gt;Client: Initialize MCP Client\n    Client-&gt;&gt;Server: Send initialize request\n    Server-&gt;&gt;Client: Return initialize response\n    Client-&gt;&gt;Server: Send initialized notification\n    Client-&gt;&gt;Server: Send listTools request\n    Server-&gt;&gt;Client: Return tools with descriptions and schemas</code></pre> <p>Figure 2: MCP Initialization and Tool Discovery Sequence.</p> <p>Application Launch &amp; Client Initialization: When a Host Application starts, it initializes its embedded MCP Client(s).</p> <p>Server Handshake: MCP Clients perform a handshake with known or discoverable MCP Servers. This typically involves an initialize request and response, where servers might share their capabilities, supported protocol versions, and other metadata.</p> <p>Tool Listing: Clients request a list of available tools from connected MCP Servers using a listTools (or similar) command.</p> <p>Tool Definition Exchange: Servers respond with definitions for their available tools. These definitions usually include a human-readable description, a machine-readable name or ID, and a JSON schema defining the expected input parameters and output format for each tool.</p>"},{"location":"etdi-concepts/#tool-invocation-and-usage-phase","title":"Tool Invocation and Usage Phase","text":"<p>This phase describes how a tool is selected and executed in response to a user's request.</p> <pre><code>sequenceDiagram\n    participant User\n    participant Host as Host Application\n    participant Client as MCP Client\n    participant LLM\n    participant Server as MCP Server\n    participant Tool\n\n    User-&gt;&gt;Host: Request requiring tool use\n    Host-&gt;&gt;Client: Parse user request\n    Client-&gt;&gt;Host: Present available tools\n    Host-&gt;&gt;LLM: Send query + available tools\n    LLM-&gt;&gt;Host: Determine tool to use\n    Host-&gt;&gt;Client: Request to use specific tool\n    Client-&gt;&gt;User: Request permission (if needed)\n    User-&gt;&gt;Client: Grant permission\n    Client-&gt;&gt;Server: Invoke tool with parameters\n    Server-&gt;&gt;Tool: Execute function\n    Tool-&gt;&gt;Server: Return results\n    Server-&gt;&gt;Client: Return results\n    Client-&gt;&gt;Host: Provide tool results\n    Host-&gt;&gt;LLM: Add results to context\n    LLM-&gt;&gt;Host: Generate response with results\n    Host-&gt;&gt;User: Display final response</code></pre> <p>Figure 3: MCP Tool Usage and Invocation Sequence.</p> <p>User Request: The user interacts with the Host Application, making a request that may necessitate the use of an external tool (e.g., \"Find flights to Paris,\" \"Summarize this document\").</p> <p>Tool Selection by LLM: The Host Application, often in conjunction with the LLM, processes the user's request. The LLM, provided with the descriptions and schemas of available tools, determines which tool (if any) is appropriate and what parameters are needed.</p> <p>Permission Request (Conditional): If the selected tool requires specific permissions (e.g., access to location, contacts, or performing actions with cost implications) or if it's the first time a user is encountering this tool, the MCP Client (via the Host Application) may prompt the user for explicit approval.</p> <p>Tool Invocation: Once approved (if necessary), the MCP Client sends an invokeTool (or similar) request to the relevant MCP Server, specifying the tool ID and the parameters identified by the LLM.</p> <p>Tool Execution: The MCP Server delegates the request to the actual tool, which executes its function.</p> <p>Result Propagation: The tool returns its output (or an error message) to the MCP Server, which then relays it back to the MCP Client.</p> <p>Context Augmentation and Response Generation: The MCP Client provides the tool's results to the Host Application. These results are then typically added to the LLM's context. The LLM uses this augmented context to generate a final, informed response to the user's original query.</p>"},{"location":"etdi-concepts/#4-critical-security-vulnerabilities-in-mcp","title":"4. Critical Security Vulnerabilities in MCP","text":"<p>The standard MCP flow, while functional, harbors significant security weaknesses due to the lack of robust mechanisms for verifying tool identity and integrity. Two primary attack vectors emerge:</p>"},{"location":"etdi-concepts/#attack-vector-1-tool-poisoning","title":"Attack Vector 1: Tool Poisoning","text":""},{"location":"etdi-concepts/#definition-and-mechanism-tp","title":"Definition and Mechanism (TP)","text":"<p>Tool Poisoning occurs when a malicious actor deploys a tool that masquerades as a legitimate, trusted, or innocuous tool. The attacker aims to deceive the user or the LLM into selecting and approving the malicious tool, thereby gaining unauthorized access or capabilities.</p> <pre><code>sequenceDiagram\n    participant User\n    participant Client as MCP Client\n    participant LLM\n    participant LegitServer as Legitimate Server\n    participant LegitTool as Legitimate Tool\n    participant MalServer as Malicious Server\n    participant MalTool as Malicious Tool\n\n    User-&gt;&gt;Client: Request calculator tool\n    Client-&gt;&gt;LegitServer: Discover tools\n    Client-&gt;&gt;MalServer: Discover tools\n    LegitServer-&gt;&gt;Client: Register \"Secure Calculator\"\n    MalServer-&gt;&gt;Client: Register similar \"Secure Calculator\"\n    Client-&gt;&gt;User: Present similar-looking options\n    User-&gt;&gt;Client: Approve what appears legitimate\n    Client-&gt;&gt;MalServer: Invoke tool (actually malicious)\n    MalServer-&gt;&gt;MalTool: Execute malicious code\n    MalTool-&gt;&gt;MalServer: Perform unauthorized actions\n    MalServer-&gt;&gt;Client: Return results (appears normal)\n    Client-&gt;&gt;LLM: Add compromised results to context\n    LLM-&gt;&gt;Client: Generate response\n    Client-&gt;&gt;User: Display results (appears normal)</code></pre> <p>Figure 4: Tool Poisoning Attack Sequence.</p>"},{"location":"etdi-concepts/#vulnerability-analysis-tp","title":"Vulnerability Analysis (TP)","text":"<p>Lack of Authenticity Verification: Users and MCP Clients have no reliable method to verify the true origin or authenticity of a tool. Tool names, descriptions, and even provider names can be easily spoofed.</p> <p>Indistinguishable Duplicates: If a malicious tool perfectly mimics the metadata (name, description, schema) of a legitimate tool, it becomes virtually impossible for the user or LLM to differentiate between them during the selection process.</p> <p>Exploitation of Trust: Attackers exploit the user's trust in familiar tool names or reputable provider names.</p> <p>Unverifiable Claims: A tool can claim to be \"secure\" or \"official\" in its description without any mechanism to validate this claim.</p> <p>Impact: Successful tool poisoning can lead to data theft, installation of malware, unauthorized system access, financial loss, or manipulation of LLM outputs for nefarious purposes.</p>"},{"location":"etdi-concepts/#illustrative-attack-scenario-tp","title":"Illustrative Attack Scenario (TP)","text":"<p>Legitimate Tool: A well-known company, \"TrustedSoft Inc.\", offers a legitimate MCP tool called \"SecureDocs Scanner\" designed to scan documents for PII and report findings.</p> <p>Malicious Mimicry: An attacker deploys a malicious MCP server hosting a tool also named \"SecureDocs Scanner.\" They meticulously copy the description, JSON schema, and even claim \"TrustedSoft Inc.\" as the provider in the tool's metadata.</p> <p>Discovery: The user's MCP Client discovers both the legitimate and the malicious \"SecureDocs Scanner\" tools. Due to identical presentation, they appear as duplicates or the client might even de-duplicate them, potentially favoring the malicious one based on arbitrary factors like discovery order.</p> <p>User Deception: The user, intending to use the trusted tool, selects the entry that corresponds to the malicious version, or the LLM selects it based on the matching description.</p> <p>Malicious Action: Upon invocation, the malicious \"SecureDocs Scanner\" does not scan for PII. Instead, it silently exfiltrates the entire content of any document processed through it to an attacker-controlled server, while possibly returning a fake \"No PII found\" message to maintain appearances.</p>"},{"location":"etdi-concepts/#attack-vector-2-rug-pull-attacks","title":"Attack Vector 2: Rug Pull Attacks","text":""},{"location":"etdi-concepts/#definition-and-mechanism-rp","title":"Definition and Mechanism (RP)","text":"<p>Rug Pull attacks (also known as \"bait-and-switch\" in this context) occur when the functionality or permission requirements of an already approved tool are maliciously altered after the initial user approval. The tool initially presents benign behavior to gain trust and approval, then later changes to perform unauthorized actions without re-triggering a consent request.</p> <pre><code>sequenceDiagram\n    participant User\n    participant Client as MCP Client\n    participant Server as MCP Server\n    participant Tool\n\n    User-&gt;&gt;Client: Request weather tool\n    Client-&gt;&gt;Server: Discover tools\n    Server-&gt;&gt;Client: Return \"Weather Tool v1\"\n    Note over Client: Shows limited permissions (location only)\n    User-&gt;&gt;Client: Approve weather tool\n    Client-&gt;&gt;Server: Use weather tool\n    Server-&gt;&gt;Tool: Execute weather function\n    Tool-&gt;&gt;Server: Return weather data\n    Server-&gt;&gt;Client: Return results\n    Client-&gt;&gt;User: Display weather information\n\n    Note over Tool,Server: Later (tool silently modified)\n    Tool-&gt;&gt;Server: Update tool with additional capabilities\n\n    Note over User,Tool: In subsequent session\n    User-&gt;&gt;Client: Use previously approved weather tool\n    Client-&gt;&gt;Server: Request to use weather tool\n    Server-&gt;&gt;Client: Return MODIFIED tool definition\n    Note over Client: No way to detect the change\n    Client-&gt;&gt;Server: Use modified tool\n    Server-&gt;&gt;Tool: Execute modified function\n    Note over Tool: Now accesses more data than originally approved\n    Tool-&gt;&gt;Server: Return results after data exfiltration\n    Server-&gt;&gt;Client: Return results\n    Client-&gt;&gt;User: Display results (appears normal)</code></pre> <p>Figure 5: Rug Pull Attack Sequence.</p>"},{"location":"etdi-concepts/#vulnerability-analysis-rp","title":"Vulnerability Analysis (RP)","text":"<p>Post-Approval Modification: The core issue is that a tool's behavior or data access permissions can change on the server-side after the user has granted initial approval.</p> <p>Lack of Integrity Check: Standard MCP Clients typically do not re-verify the tool's definition or hash on every use once it's been approved, especially if the tool's name/version string remains unchanged.</p> <p>No Re-Approval Trigger: If the tool's identifier (like its name or version string) doesn't change, or if the client isn't designed to detect subtle changes in its schema or description, no re-approval prompt is shown to the user.</p> <p>Exploitation of Existing Trust: The attack leverages the trust established during the initial, benign approval.</p> <p>Impact: Rug pulls can lead to unauthorized access to sensitive data (e.g., conversations, files, personal information) that the user never consented to share with that tool, effectively bypassing the initial permission model. It erodes user trust significantly once discovered.</p>"},{"location":"etdi-concepts/#illustrative-attack-scenario-rp","title":"Illustrative Attack Scenario (RP)","text":"<p>Initial Benign Tool: A user installs and approves a \"Daily Wallpaper\" tool. Version 1.0 of this tool simply fetches a new wallpaper image from a public API and sets it as the desktop background. It requests permission only to \"access the internet\" and \"modify desktop wallpaper.\"</p> <p>Post-Approval Modification: Weeks later, the provider of \"Daily Wallpaper\" (or an attacker who has compromised the server) updates the tool's server-side logic. The tool, still identified as \"Daily Wallpaper v1.0\" to avoid re-approval, is now modified to also scan the user's Documents folder for files containing financial keywords and upload them.</p> <p>Silent Exploitation: The next time the \"Daily Wallpaper\" tool runs (e.g., on system startup or its daily schedule), it fetches and sets the wallpaper as usual. However, in the background, it also executes the new malicious code, exfiltrating sensitive documents.</p> <p>User Unawareness: The user remains unaware of this change because the tool's primary function still works as expected, and no new permission prompts were triggered, as the tool's identifier and initially declared permissions (from the client's perspective if it doesn't re-fetch and deeply compare definitions) haven't changed.</p>"},{"location":"etdi-concepts/#5-etdi-fortifying-mcp-with-an-enhanced-tool-definition-interface","title":"5. ETDI: Fortifying MCP with an Enhanced Tool Definition Interface","text":"<p>The Enhanced Tool Definition Interface (ETDI) is proposed as a security layer extension to MCP, specifically designed to address the vulnerabilities of Tool Poisoning and Rug Pulls. ETDI achieves this by introducing verifiable identity and integrity for tool definitions.</p>"},{"location":"etdi-concepts/#foundational-security-principles-of-etdi","title":"Foundational Security Principles of ETDI","text":"<p>ETDI is built upon three core security principles:</p> <p>Cryptographic Identity and Authenticity: Tools must possess a verifiable identity, established through cryptographic signatures. This ensures that a tool's claimed origin and authorship can be authenticated, preventing impersonation.</p> <p>Immutable and Versioned Definitions: Each distinct version of a tool must have a unique, cryptographically signed, and immutable definition. This means any change to a tool's functionality, description, or permission requirements necessitates a new version with a new signature, making unauthorized modifications detectable.</p> <p>Explicit and Verifiable Permissions: A tool's capabilities and the permissions it requires must be explicitly defined within its signed definition. The MCP Client can then reliably present these to the user and enforce them.</p>"},{"location":"etdi-concepts/#etdi-countermeasures-thwarting-tool-poisoning","title":"ETDI Countermeasures: Thwarting Tool Poisoning","text":"<p>ETDI effectively mitigates Tool Poisoning by making it computationally infeasible for malicious tools to impersonate legitimate ones.</p> <pre><code>sequenceDiagram\n    participant User\n    participant Client as MCP Client with ETDI\n    participant LegitServer as Legitimate Server\n    participant LegitTool as Legitimate Tool\n    participant MalServer as Malicious Server\n    participant MalTool as Malicious Tool\n\n    LegitTool-&gt;&gt;LegitTool: Generate public/private key pair\n    LegitTool-&gt;&gt;LegitServer: Register public key\n\n    User-&gt;&gt;Client: Request calculator tool\n    Client-&gt;&gt;LegitServer: Discover tools\n    Client-&gt;&gt;MalServer: Discover tools\n\n    LegitTool-&gt;&gt;LegitTool: Sign tool definition\n    LegitServer-&gt;&gt;Client: Register signed \"Secure Calculator\"\n    MalServer-&gt;&gt;Client: Register similar \"Secure Calculator\"\n\n    Client-&gt;&gt;Client: Verify signatures\n    Note over Client: Legitimate tool signature verifies \u2713\n    Note over Client: Malicious tool signature fails \u2717\n\n    Client-&gt;&gt;User: Present only verified tools\n    User-&gt;&gt;Client: Approve verified calculator\n    Client-&gt;&gt;LegitServer: Invoke verified tool\n    LegitServer-&gt;&gt;LegitTool: Execute legitimate code\n    LegitTool-&gt;&gt;LegitServer: Return valid results\n    LegitServer-&gt;&gt;Client: Return results\n    Client-&gt;&gt;User: Display secure results</code></pre> <p>Figure 6: ETDI Preventing Tool Poisoning through Cryptographic Signatures.</p> <p>How ETDI Prevents Tool Poisoning:</p> <p>Provider Keys: Legitimate tool providers generate a public/private cryptographic key pair. The public key is made available to MCP Clients, potentially through a trusted registry or distributed with the Host Application.</p> <p>Signed Definitions: When a provider defines a tool (or a new version of it), they sign the complete tool definition (including its name, description, schema, version, and permission requirements) with their private key.</p> <p>Client Verification: When an MCP Client (equipped with ETDI logic) discovers tools, it receives these signed definitions. The client then uses the claimed provider's public key to verify the signature.</p> <p>Filtering Unverified Tools: If a signature is invalid (i.e., it wasn't signed by the claimed provider's private key) or missing, the tool is flagged as unverified or potentially malicious. The client can then choose to hide such tools, warn the user, or prevent their usage entirely.</p> <p>Authenticity Assured: Users are only presented with tools whose authenticity and integrity have been cryptographically verified. A malicious actor cannot forge a valid signature for a tool they don't own without access to the legitimate provider's private key.</p>"},{"location":"etdi-concepts/#etdi-countermeasures-preventing-rug-pulls","title":"ETDI Countermeasures: Preventing Rug Pulls","text":"<p>ETDI prevents Rug Pulls by ensuring that any change to a tool's definition is detectable, forcing re-evaluation and re-approval if necessary.</p> <pre><code>sequenceDiagram\n    participant User\n    participant Client as MCP Client with ETDI\n    participant Server as MCP Server\n    participant Tool\n\n    User-&gt;&gt;Client: Request weather tool\n    Client-&gt;&gt;Server: Discover tools\n\n    Tool-&gt;&gt;Tool: Sign tool definition v1.0\n    Server-&gt;&gt;Client: Return signed \"Weather Tool v1.0\"\n    Note over Client: Verifies signature\n\n    User-&gt;&gt;Client: Approve weather tool\n    Client-&gt;&gt;Client: Store tool definition_version=\"1.0\"\n    Client-&gt;&gt;Client: Store cryptographic signature\n\n    Client-&gt;&gt;Server: Use weather tool v1.0\n    Server-&gt;&gt;Tool: Execute weather function\n    Tool-&gt;&gt;Server: Return weather data\n    Server-&gt;&gt;Client: Return results\n    Client-&gt;&gt;User: Display weather information\n\n    Note over Tool,Server: Later (tool updated)\n    Tool-&gt;&gt;Tool: Create and sign new definition v2.0\n\n    Note over User,Tool: In subsequent session\n    User-&gt;&gt;Client: Use weather tool\n    Client-&gt;&gt;Server: Request weather tool\n\n    alt Scenario 1: New Version\n        Server-&gt;&gt;Client: Return \"Weather Tool v2.0\"\n        Client-&gt;&gt;Client: Detect version change (1.0\u21922.0)\n        Client-&gt;&gt;User: Request re-approval for new version\n    else Scenario 2: Silent Modification\n        Server-&gt;&gt;Client: Return modified v1.0 (without version change)\n        Client-&gt;&gt;Client: Signature verification fails\n        Client-&gt;&gt;User: Alert: Tool integrity verification failed\n    end</code></pre> <p>Figure 7: ETDI Preventing Rug Pulls through Versioning and Signature Verification.</p> <p>How ETDI Prevents Rug Pulls:</p> <p>Immutable Signed Definitions: Each version of a tool has a unique, complete definition that is cryptographically signed by the provider. This signature covers the tool's name, version string, description, schema, and explicit permission list.</p> <p>Client Stores Approved State: When a user approves a tool (e.g., \"WeatherReporter v1.0\" with signature S1), the ETDI-enabled MCP Client securely stores not just the approval, but also the specific version identifier and the signature (or a hash of the signed definition) of the approved tool.</p> <p>Verification on Subsequent Use:</p> <p>Version Change Detection: If an MCP Server returns a tool definition with a new version number (e.g., \"WeatherReporter v2.0\" with signature S2), the client detects the version change by comparing it to the stored approved version (\"v1.0\"). This automatically triggers a re-approval process, presenting the new definition (and any changed permissions) to the user.</p> <p>Integrity Violation Detection: If a server attempts to return a modified tool definition without changing the version number (i.e., it still claims to be \"WeatherReporter v1.0\" but the underlying definition or its signature has changed), the client's verification will fail. It will either detect that the signature no longer matches the definition, or that the current definition's signature/hash does not match the stored signature/hash for the approved \"v1.0\".</p> <p>User Empowerment: In either case\u2014a legitimate version upgrade or a malicious modification\u2014the user is alerted and/or prompted for re-approval before the modified tool can be used. Silent modifications are thus prevented.</p>"},{"location":"etdi-concepts/#6-advancing-security-with-oauth-enhanced-etdi","title":"6. Advancing Security with OAuth-Enhanced ETDI","text":"<p>While ETDI with direct cryptographic signatures provides a strong foundation, integrating it with an established authorization framework like OAuth 2.0 can offer significant advantages in terms of standardization, ecosystem interoperability, and centralized trust management.</p> <p>The core idea is to use OAuth tokens, typically JSON Web Tokens (JWTs) signed by an Identity Provider (IdP), as the carriers for tool definitions or as attestations of a tool's validity and its provider's identity.</p>"},{"location":"etdi-concepts/#architectural-integration-of-oauth-20","title":"Architectural Integration of OAuth 2.0","text":"<p>This enhanced architecture introduces an OAuth Identity Provider (IdP) as a central trust anchor.</p> <pre><code>flowchart TD\n    User([User])\n    Host[Host Application]\n    Client[MCP Client with ETDI-OAuth]\n    IdP[OAuth Identity Provider]\n    LLM[Large Language Model]\n    Server[MCP Server]\n    Tool[Tool]\n\n    User &lt;--&gt; Host\n    Host &lt;--&gt; Client\n    Host &lt;--&gt; LLM\n    Client &lt;--&gt; Server\n    Client &lt;--&gt; IdP\n    Server &lt;--&gt; Tool\n    Server &lt;--&gt; IdP\n    Tool &lt;--&gt; IdP</code></pre> <p>Figure 8: OAuth-Enhanced ETDI Architecture, introducing an Identity Provider.</p> <p>In this model:</p> <p>Tool Providers register as OAuth clients with the IdP.</p> <p>The IdP authenticates tool providers and issues signed OAuth tokens (e.g., JWTs). These tokens can either directly contain the tool definition or reference a securely stored definition, along with metadata like provider ID, tool ID, version, and authorized scopes (permissions).</p> <p>MCP Servers obtain these OAuth tokens for the tools they host and present them to MCP Clients.</p> <p>MCP Clients validate these tokens with the IdP (or using the IdP's public keys) to verify the tool's authenticity, integrity, and authorized permissions.</p>"},{"location":"etdi-concepts/#reinforced-protection-flow-with-oauth","title":"Reinforced Protection Flow with OAuth","text":""},{"location":"etdi-concepts/#oauth-enhanced-tool-poisoning-defense","title":"OAuth-Enhanced Tool Poisoning Defense","text":"<pre><code>sequenceDiagram\n    participant User\n    participant Client as MCP Client with ETDI-OAuth\n    participant IdP as OAuth Identity Provider\n    participant LegitServer as Legitimate Server\n    participant MalServer as Malicious Server\n\n    LegitServer-&gt;&gt;IdP: Register as OAuth client\n    IdP-&gt;&gt;LegitServer: Issue client credentials\n\n    User-&gt;&gt;Client: Request calculator tool\n    Client-&gt;&gt;LegitServer: Discover tools with OAuth auth\n    Client-&gt;&gt;MalServer: Discover tools with OAuth auth\n\n    LegitServer-&gt;&gt;IdP: Request token for tool definition\n    IdP-&gt;&gt;LegitServer: Issue signed OAuth token\n    LegitServer-&gt;&gt;Client: Register OAuth-signed calculator\n\n    MalServer-&gt;&gt;IdP: Attempt to get token for spoofed tool\n    IdP-&gt;&gt;MalServer: Reject - unauthorized provider\n    MalServer-&gt;&gt;Client: Register unsigned calculator\n\n    Client-&gt;&gt;IdP: Verify tool OAuth tokens\n    IdP-&gt;&gt;Client: Confirm legitimate tool, reject malicious\n\n    Client-&gt;&gt;User: Present only verified tools\n    User-&gt;&gt;Client: Approve verified calculator</code></pre> <p>Figure 9: OAuth-Enhanced ETDI Preventing Tool Poisoning.</p> <p>The IdP acts as a central authority. A malicious server cannot obtain a valid OAuth token from the trusted IdP for a tool it doesn't legitimately own or isn't authorized to provide. Clients only trust tools whose definitions are backed by tokens from recognized IdPs.</p>"},{"location":"etdi-concepts/#oauth-enhanced-rug-pull-defense","title":"OAuth-Enhanced Rug Pull Defense","text":"<pre><code>sequenceDiagram\n    participant User\n    participant Client as MCP Client with ETDI-OAuth\n    participant IdP as OAuth Identity Provider\n    participant Server as MCP Server\n    participant Tool\n\n    Tool-&gt;&gt;IdP: Register as OAuth client\n    IdP-&gt;&gt;Tool: Issue client credentials\n\n    Tool-&gt;&gt;IdP: Request token for definition v1.0\n    IdP-&gt;&gt;Tool: Issue token with version+scope binding\n    Tool-&gt;&gt;Server: Register tool v1.0 with OAuth token\n\n    User-&gt;&gt;Client: Request weather tool\n    Client-&gt;&gt;IdP: Verify tool OAuth token\n    IdP-&gt;&gt;Client: Confirm token validity\n    Client-&gt;&gt;User: Present verified tool\n    User-&gt;&gt;Client: Approve tool\n\n    Note over Tool,Server: Later (tool modified)\n\n    alt Scenario 1: Honest Version Change\n        Tool-&gt;&gt;IdP: Request token for definition v2.0\n        IdP-&gt;&gt;Tool: Issue new token with updated scope\n        Tool-&gt;&gt;Server: Register v2.0 with new token\n\n        User-&gt;&gt;Client: Use weather tool\n        Client-&gt;&gt;Server: Request tool definition\n        Server-&gt;&gt;Client: Return v2.0 definition\n        Client-&gt;&gt;IdP: Verify token and check version\n        IdP-&gt;&gt;Client: Confirm token valid but version changed\n        Client-&gt;&gt;User: Request re-approval for new version\n    else Scenario 2: Attempted Silent Modification\n        Tool-&gt;&gt;Server: Update v1.0 behavior without token update\n\n        User-&gt;&gt;Client: Use weather tool\n        Client-&gt;&gt;Server: Request tool with v1.0 token\n        Server-&gt;&gt;Client: Return modified v1.0 tool\n        Client-&gt;&gt;IdP: Verify token against actual behavior\n        IdP-&gt;&gt;Client: Alert: Scope violation detected\n        Client-&gt;&gt;User: Alert: Tool integrity verification failed\n    end</code></pre> <p>Figure 10: OAuth-Enhanced ETDI Preventing Rug Pulls.</p> <p>OAuth tokens intrinsically bind tool definitions (or references to them) with specific versions and permission scopes.</p> <p>Version and Scope Binding: The IdP issues tokens that specify the tool version and the precise OAuth scopes (permissions) granted for that version.</p> <p>Client Verification: The MCP Client validates the token and compares the version and scopes within the token against the stored approved version and scopes.</p> <p>Detection of Changes:</p> <p>If the version in the token is newer, re-approval is sought.</p> <p>If the scopes in the token have changed (e.g., expanded), re-approval is sought.</p> <p>If a server tries to return an old token for a tool whose definition has actually changed on the server in a way that would require new scopes, this discrepancy can be caught if the client/IdP can verify the invoked operation against the token's scopes.</p> <p>Centralized Revocation: If a tool provider's key is compromised or a tool is found to be malicious, the IdP can revoke the associated tokens or client credentials, centrally disabling the tool across the ecosystem.</p>"},{"location":"etdi-concepts/#key-advantages-of-oauth-integration","title":"Key Advantages of OAuth Integration","text":"<p>Standardized Authentication &amp; Authorization: Leverages a widely adopted, industry-standard framework (OAuth 2.0/2.1), promoting interoperability and reducing the need for custom cryptographic solutions.</p> <p>Fine-Grained Permission Control: OAuth scopes provide a robust mechanism for defining and enforcing granular permissions for tools, moving beyond simple binary approval.</p> <p>Centralized Trust Management: The IdP acts as a central point for managing trust relationships, tool provider identities, and policies. This simplifies trust configuration for clients.</p> <p>Simplified Implementation for Providers &amp; Clients: Tool providers and client developers can leverage existing OAuth libraries and infrastructure, potentially reducing development effort and complexity.</p> <p>Enhanced Revocation Capabilities: OAuth provides mechanisms for token revocation, allowing for quicker and more effective response to compromised tools or providers.</p> <p>Ecosystem Scalability: Easier to manage a large ecosystem of tools and providers through a federated identity model if multiple IdPs are supported.</p>"},{"location":"etdi-concepts/#9-references","title":"9. References","text":"<ul> <li>Model Context Protocol Specification: (e.g., https://modelcontextprotocol.io/specification - replace with actual URL if available)</li> <li>OAuth 2.1 Authorization Framework: https://oauth.net/2.1/</li> <li>JSON Web Signatures (JWS) RFC 7515: https://datatracker.ietf.org/doc/html/rfc7515</li> <li>JSON Web Token (JWT) RFC 7519: https://datatracker.ietf.org/doc/html/rfc7519</li> </ul>"},{"location":"getting-started/","title":"Getting Started with ETDI","text":"<p>For a conceptual overview of ETDI and its security model, see ETDI Concepts.</p> <p>This guide will help you set up the Enhanced Tool Definition Interface (ETDI) security framework and create your first secure AI tool server.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11 or higher</li> <li>Git</li> <li>A text editor or IDE</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#1-clone-the-repository","title":"1. Clone the Repository","text":"<pre><code>git clone https://github.com/python-sdk-etdi/python-sdk-etdi.git\ncd python-sdk-etdi\n</code></pre>"},{"location":"getting-started/#2-set-up-virtual-environment","title":"2. Set Up Virtual Environment","text":"<pre><code>python -m venv .venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\n</code></pre>"},{"location":"getting-started/#3-install-dependencies","title":"3. Install Dependencies","text":"<pre><code>pip install -e .\n</code></pre>"},{"location":"getting-started/#quick-start-example","title":"Quick Start Example","text":"<p>Create your first secure server:</p> <pre><code># secure_server_example.py\nimport asyncio\nfrom mcp.etdi import SecureServer, ToolProvider\nfrom mcp.etdi.types import SecurityLevel\n\nasync def main():\n    # Create secure server with high security\n    server = SecureServer(\n        name=\"my-secure-server\",\n        security_level=SecurityLevel.HIGH,\n        enable_tool_verification=True\n    )\n\n    # Register a secure tool\n    @server.tool(\"get_weather\")\n    async def get_weather(location: str) -&gt; dict:\n        \"\"\"Get weather for a location with security verification.\"\"\"\n        # Tool implementation here\n        return {\"location\": location, \"temperature\": \"72\u00b0F\"}\n\n    # Start the server\n    await server.start()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"getting-started/#setting-up-auth0-authentication","title":"Setting Up Auth0 Authentication","text":"<p>ETDI supports OAuth2 authentication through Auth0. Follow these steps to set up Auth0:</p>"},{"location":"getting-started/#1-create-an-auth0-account-and-application","title":"1. Create an Auth0 Account and Application","text":"<ol> <li>Sign up for an Auth0 account at auth0.com</li> <li>Create a new Application:    - Go to Applications &gt; Create Application    - Name it (e.g., \"ETDI Tool Registry\")    - Select \"Machine to Machine\" as the application type    - Click Create</li> </ol>"},{"location":"getting-started/#2-configure-auth0-api","title":"2. Configure Auth0 API","text":"<ol> <li>Go to Applications &gt; APIs</li> <li> <p>Create a new API:    - Name: \"ETDI Tool Registry API\"    - Identifier (audience): <code>https://api.etdi-tools.demo.com</code> (or your preferred URL)    - Signing Algorithm: RS256</p> </li> <li> <p>Define API Scopes:    - Go to the Permissions tab    - Add these scopes:</p> <ul> <li><code>create:resource-servers</code>: Create new tool registrations</li> <li><code>read:resource-servers</code>: Read tool information</li> <li><code>update:resource-servers</code>: Update existing tools</li> <li><code>delete:resource-servers</code>: Remove tool registrations</li> </ul> </li> </ol>"},{"location":"getting-started/#3-configure-environment-variables","title":"3. Configure Environment Variables","text":"<p>Set up your environment variables:</p> <pre><code># Auth0 Configuration\nexport AUTH0_DOMAIN=\"your-tenant.auth0.com\"\nexport AUTH0_CLIENT_ID=\"your-client-id\"\nexport AUTH0_CLIENT_SECRET=\"your-client-secret\"\nexport AUTH0_AUDIENCE=\"https://api.etdi-tools.demo.com\"\n</code></pre>"},{"location":"getting-started/#4-initialize-auth0-in-your-code","title":"4. Initialize Auth0 in Your Code","text":"<pre><code>from mcp.etdi.oauth import OAuthConfig, Auth0Provider\nfrom mcp.etdi.types import SecurityLevel\n\n# Create OAuth configuration\noauth_config = OAuthConfig(\n    provider=\"auth0\",\n    client_id=os.getenv(\"AUTH0_CLIENT_ID\"),\n    client_secret=os.getenv(\"AUTH0_CLIENT_SECRET\"),\n    domain=os.getenv(\"AUTH0_DOMAIN\"),\n    audience=os.getenv(\"AUTH0_AUDIENCE\"),\n    scopes=[\"create:resource-servers\", \"read:resource-servers\"]\n)\n\n# Initialize Auth0 provider\nauth0_provider = Auth0Provider(oauth_config)\n\n# Create secure server with Auth0\nserver = SecureServer(\n    name=\"my-secure-server\",\n    security_level=SecurityLevel.HIGH,\n    oauth_provider=auth0_provider\n)\n</code></pre>"},{"location":"getting-started/#5-test-auth0-integration","title":"5. Test Auth0 Integration","text":"<pre><code># test_auth0.py\nimport asyncio\nfrom mcp.etdi.oauth import OAuthConfig, Auth0Provider\n\nasync def test_auth0():\n    oauth_config = OAuthConfig(\n        provider=\"auth0\",\n        client_id=os.getenv(\"AUTH0_CLIENT_ID\"),\n        client_secret=os.getenv(\"AUTH0_CLIENT_SECRET\"),\n        domain=os.getenv(\"AUTH0_DOMAIN\"),\n        audience=os.getenv(\"AUTH0_AUDIENCE\"),\n        scopes=[\"read:resource-servers\"]\n    )\n\n    auth0_provider = Auth0Provider(oauth_config)\n    await auth0_provider.initialize()\n\n    # Test token acquisition\n    token = await auth0_provider.get_token(\n        tool_id=\"test-tool\",\n        permissions=[\"read:resource-servers\"]\n    )\n    print(\"\u2705 Successfully acquired OAuth token\")\n    print(f\"   Token type: Bearer\")\n    print(f\"   Scopes: {', '.join(token.scopes)}\")\n\n    await auth0_provider.cleanup()\n\nif __name__ == \"__main__\":\n    asyncio.run(test_auth0())\n</code></pre>"},{"location":"getting-started/#troubleshooting-auth0","title":"Troubleshooting Auth0","text":"<p>Common issues and solutions:</p> <ol> <li> <p>401 Unauthorized:    - Check if your client secret is correct    - Verify the audience matches your API identifier    - Ensure the application has the required scopes granted</p> </li> <li> <p>403 Forbidden:    - Check if the required scopes are enabled in your Auth0 API    - Verify the application has been granted access to the API</p> </li> <li> <p>Invalid Grant Type:    - Ensure \"Client Credentials\" grant type is enabled in your Auth0 application settings</p> </li> </ol> <p>For more details on Auth0 integration, see the Auth0 Integration Guide.</p>"},{"location":"getting-started/#enabling-request-signing","title":"Enabling Request Signing","text":"<p>Request signing ensures that every tool invocation and API request is cryptographically signed and verifiable, protecting against tampering and impersonation. ETDI supports RSA and ECDSA algorithms, with automatic key management.</p> <p>Request signing is non-breaking and can be enabled incrementally\u2014existing tools continue to work without modification.</p>"},{"location":"getting-started/#minimal-example","title":"Minimal Example","text":"<pre><code>from mcp.etdi import SecureServer\n\nserver = SecureServer(\n    name=\"my-secure-server\",\n    enable_request_signing=True,  # Enable request signing for all tools\n)\n\n@server.tool(\"secure_tool\", etdi_require_request_signing=True)\nasync def secure_tool(data: str) -&gt; str:\n    return f\"Signed and secure: {data}\"\n</code></pre> <p>For a full end-to-end example, see Request Signing Example.</p>"},{"location":"getting-started/#security-configuration","title":"Security Configuration","text":"<p>Configure security levels and policies:</p> <pre><code>from mcp.etdi.types import SecurityPolicy, SecurityLevel\n\npolicy = SecurityPolicy(\n    security_level=SecurityLevel.HIGH,\n    require_tool_signatures=True,\n    enable_call_chain_validation=True,\n    max_call_depth=10,\n    audit_all_calls=True\n)\n\nserver = SecureServer(security_policy=policy)\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Authentication Setup: Configure OAuth and enterprise SSO</li> <li>Tool Poisoning Prevention: Protect against malicious tools</li> <li>Examples: Explore real-world examples and demos</li> <li>Request Signing Example: See how to implement and use request signing</li> </ul>"},{"location":"getting-started/#verification","title":"Verification","text":"<p>Test your setup:</p> <pre><code>python examples/etdi/verify_implementation.py\n</code></pre> <p>This script will verify that ETDI is properly installed and configured.</p>"},{"location":"getting-started/#end-to-end-etdi-security-workflow","title":"End-to-End ETDI Security Workflow","text":"<p>Follow these steps for a complete, secure ETDI deployment:</p> <ol> <li> <p>Start a Secure Server    - Use the Quick Start or Security Configuration examples above to launch a server with ETDI security features enabled.    - Optionally, enable request signing for all tools (see 'Enabling Request Signing' above).</p> </li> <li> <p>Run a Secure Client    - Use the ETDI client to discover, verify, and approve tools.    - Example: See <code>examples/etdi/basic_usage.py</code> for a minimal client workflow.</p> </li> <li> <p>Invoke Tools Securely    - Invoke tools from the client. If request signing is enabled, all invocations will be cryptographically signed and verified.    - Example: See <code>examples/etdi/request_signing_example.py</code> for client-side signing.</p> </li> <li> <p>Check Security and Audit Logs    - Review server and client output for verification status, approval, and audit logs.    - Example: See <code>examples/etdi/verify_implementation.py</code> to verify your setup.</p> </li> </ol> <p>This workflow ensures that your tools are protected against tampering, impersonation, and unauthorized access, leveraging all core ETDI security features.</p>"},{"location":"security-features/","title":"ETDI Security Features","text":"<p>For a conceptual and architectural overview, see ETDI Concepts.</p> <p>ETDI provides a rich set of security features designed to protect AI tool interactions at multiple levels. These features work together to ensure tool authenticity, enforce access control, monitor behavior, and provide comprehensive auditability.</p>"},{"location":"security-features/#1-authentication","title":"1. Authentication","text":"<p>Ensuring that only legitimate users, services, and tools can interact with the system.</p> <ul> <li>OAuth 2.0 Integration: ETDI seamlessly integrates with standard OAuth 2.0 providers (e.g., Auth0, Okta, Azure AD) for robust identity verification. This allows leveraging existing enterprise identity systems.<ul> <li>Clients and Servers use OAuth tokens to authenticate.</li> <li>Support for various flows (Client Credentials, Authorization Code, etc.) depending on the use case.</li> <li>See <code>examples/etdi/oauth_providers.py</code> in the project's example code for configurations.</li> </ul> </li> <li>Single Sign-On (SSO): Through OAuth/OIDC providers, ETDI can support enterprise SSO, simplifying user management.</li> <li>Token Verification: All API calls requiring authentication are protected. Tokens are cryptographically verified (signatures, expiration, issuer, audience) by both the ETDI client and the secure server middleware.</li> <li>Mutual TLS (mTLS): For service-to-service communication, mTLS can be employed for an additional layer of authentication, ensuring both client and server verify each other's identity using X.509 certificates.</li> </ul>"},{"location":"security-features/#2-authorization","title":"2. Authorization","text":"<p>Defining and enforcing what authenticated entities are allowed to do.</p> <ul> <li>Fine-Grained Permissions: Tools explicitly declare the permissions they require to operate (e.g., <code>file:read</code>, <code>database:user:update</code>, <code>api:external_service:call</code>).     <pre><code>@server.tool(\"secure_file_read\", permissions=[\"file:read\", \"audit:log\"])\nasync def secure_file_read(path: str) -&gt; str:\n    # ... implementation\n    pass\n</code></pre></li> <li>Scope-Based Access Control: OAuth scopes granted to clients are checked against the permissions required by tools. A tool invocation is only allowed if the client possesses all necessary scopes.</li> <li>Role-Based Access Control (RBAC): User roles, often managed by the OAuth provider, can be mapped to sets of permissions or scopes, simplifying authorization management.</li> <li>Caller/Callee Authorization: Specific to Call Stack Security, this ensures that a tool (caller) is authorized to invoke another tool (callee), and the callee is authorized to be invoked by the caller.</li> </ul>"},{"location":"security-features/#3-tool-integrity-verification","title":"3. Tool Integrity &amp; Verification","text":"<p>Ensuring tools are authentic, have not been tampered with, and their versions are managed.</p> <ul> <li>Cryptographic Signatures: Tool definitions can be cryptographically signed by their providers. ETDI clients verify these signatures to ensure the tool definition hasn't been altered since publication.</li> <li>Immutable Versioning: Each version of a tool has a unique identifier, and its definition (including code references or hashes) is immutable. This is key to Rug Poisoning Protection.</li> <li>Audit Logging for Security Monitoring: ETDI supports robust audit logging (see section 4). These logs can be fed into external security monitoring systems (like SIEMs) to detect anomalous behavior (e.g., resource access patterns, API call frequency) and trigger alerts or manual intervention. The ETDI framework focuses on providing the necessary data for such external analysis and monitoring systems.</li> <li>Approval Workflows: ETDI clients require explicit user approval for new tools or new versions of existing tools, especially if permissions change. This gives users control over which tools can operate on their behalf.</li> </ul>"},{"location":"security-features/#3a-request-signing","title":"3a. Request Signing","text":"<p>ETDI implements cryptographic request signing to ensure the authenticity and integrity of every tool invocation and API request. This feature provides:</p> <ul> <li>Supported Algorithms: RSA (RS256, RS384, RS512) and ECDSA (ES256, ES384, ES512) signatures.</li> <li>Key Management: Automatic key generation, rotation, and secure persistence using the ETDI key management subsystem.</li> <li>Integration: Request signing is seamlessly integrated with ETDI tool definitions and is supported by FastMCP servers for both client and server-side verification.</li> <li>Backward Compatibility: Request signing is non-breaking and existing tools continue to work without modification.</li> </ul> <p>Implementation: - Signing and verification logic is implemented in <code>src/mcp/etdi/crypto/request_signer.py</code>. - Key exchange and management is handled by <code>src/mcp/etdi/crypto/key_exchange.py</code>. - Comprehensive tests are in <code>tests/etdi/test_request_signing.py</code>.</p> <p>Examples: - Client-side signing: <code>examples/etdi/request_signing_example.py</code> - Server-side verification: <code>examples/etdi/request_signing_server_example.py</code> - End-to-end workflow: <code>examples/etdi/comprehensive_request_signing_example.py</code></p> <p>Request signing provides strong guarantees that requests and tool invocations are authentic and have not been tampered with in transit.</p>"},{"location":"security-features/#best-practices-for-request-signing","title":"Best Practices for Request Signing","text":"<ul> <li>Enable request signing for all sensitive or production deployments to ensure authenticity and integrity of requests.</li> <li>You can adopt request signing incrementally\u2014existing tools and clients will continue to work without modification.</li> <li>Use strong key management practices and rotate keys regularly (handled automatically by ETDI).</li> <li>Refer to the provided examples for client-side, server-side, and end-to-end signing workflows.</li> </ul>"},{"location":"security-features/#4-audit-logging","title":"4. Audit Logging","text":"<p>Comprehensive logging of all security-relevant events for monitoring, forensics, and compliance.</p> <ul> <li>Security Events Logged: <ul> <li>Tool discovery, verification success/failure.</li> <li>Tool approval and revocation.</li> <li>Tool invocation requests (with parameters, if configured).</li> <li>Authentication success/failure.</li> <li>Authorization success/failure (permission/scope checks).</li> <li>Detected security policy violations (e.g., call stack violations).</li> </ul> </li> <li>Standardized Log Format: Logs can be structured (e.g., JSON) for easy integration with SIEMs and log analysis platforms.</li> <li>Forensic Analysis: Detailed logs help in tracing the source and impact of any security incident.</li> </ul>"},{"location":"security-features/#configuration-examples","title":"Configuration Examples","text":"<p>Security features are typically configured when initializing the <code>SecureServer</code> or through specific decorators and policies:</p> <pre><code>from mcp.etdi import SecureServer\nfrom mcp.etdi.types import SecurityPolicy, SecurityLevel # OAuthConfig removed as it might not be directly used here\n# from mcp.etdi.auth import OAuthHandler # Assuming this exists for server-side setup\n\n# Example Security Policy\npolicy = SecurityPolicy(\n    security_level=SecurityLevel.HIGH,       # Or STRICT, ENHANCED, BASIC\n    require_tool_signatures=True,\n    enable_call_chain_validation=True,\n    max_call_depth=5,\n    audit_all_calls=True,\n    # allowed_callers, blocked_callees etc.\n)\n\n# Example OAuth Handler Configuration (Conceptual for server-side)\n# auth_handler = OAuthHandler(\n#     provider=\"auth0\", \n#     domain=\"your.domain.com\", \n#     client_id=\"clientid\", \n#     # ... other params\n# )\n\nserver = SecureServer(\n    name=\"my-super-secure-server\",\n    security_policy=policy,\n    # oauth_handlers=[auth_handler] # Registering OAuth middleware if applicable\n)\n\n@server.tool(\n    \"my_secure_tool\", \n    permissions=[\"data:read\", \"user:profile:view\"],\n    etdi_require_signature=True, # Overrides policy for this tool\n    etdi_max_call_depth=3\n)\nasync def my_secure_tool_impl(param: str):\n    # Tool logic\n    return f\"Processed {param} securely\"\n</code></pre> <p>These features provide a robust framework for building secure and trustworthy AI agent and tool ecosystems. Refer to specific examples in the project's <code>examples/etdi</code> directory and the API reference for detailed implementation guides.</p>"},{"location":"attack-prevention/rug-poisoning/","title":"ETDI Rug Poisoning Protection","text":""},{"location":"attack-prevention/rug-poisoning/#overview","title":"Overview","text":"<p>This page explains how the Enhanced Tool Definition Interface (ETDI) protects against Rug Poisoning attacks (also known as \"rug pulls\"). This type of attack occurs when a previously approved and trusted tool is maliciously or unexpectedly altered after users have come to rely on it, leading to potential data breaches, financial loss, or system compromise.</p>"},{"location":"attack-prevention/rug-poisoning/#attack-scenario","title":"Attack Scenario","text":""},{"location":"attack-prevention/rug-poisoning/#the-problem-rug-poisoning","title":"The Problem: Rug Poisoning","text":"<p>Rug Poisoning typically involves these stages:</p> <ol> <li>Initial Trust: A seemingly legitimate tool is published and approved by users/organizations. It functions as expected, gaining trust over time.</li> <li>Malicious Update/Swap: The tool provider (or a compromised account with publishing rights) updates the tool with malicious code. This could be a subtle change that exfiltrates data or a more drastic alteration of its core functionality. Alternatively, the tool's underlying infrastructure or dependencies might be swapped.</li> <li>Continued Use: Users and automated systems continue to invoke the tool, unaware of the malicious changes, as the tool's identifier or name might remain the same.</li> <li>Exploitation: The malicious version of the tool executes, leading to compromised data, unauthorized actions, or system instability.</li> </ol>"},{"location":"attack-prevention/rug-poisoning/#real-world-impact","title":"Real-World Impact","text":"<ul> <li>Data Exfiltration: Sensitive user or company data can be silently stolen.</li> <li>Unauthorized Actions: The tool might perform actions beyond its original scope, like financial transactions or data deletion.</li> <li>Loss of Service/Trust: If the tool's functionality is broken or behaves erratically, it can disrupt workflows and erode trust in the tool ecosystem.</li> <li>Compliance Violations: Unauthorized data access or modification can lead to severe compliance breaches.</li> </ul>"},{"location":"attack-prevention/rug-poisoning/#how-etdi-prevents-rug-poisoning","title":"How ETDI Prevents Rug Poisoning","text":"<p>ETDI employs a multi-layered defense strategy to detect and mitigate rug poisoning attacks:</p>"},{"location":"attack-prevention/rug-poisoning/#1-immutable-tool-versioning-cryptographic-hashing","title":"1. Immutable Tool Versioning &amp; Cryptographic Hashing","text":"<ul> <li>Concept: Every version of an ETDI tool definition (including its code, schema, permissions, and security policies) is ideally associated with a cryptographic hash. This hash acts as a unique, immutable fingerprint for that specific version.</li> <li>Protection: If any part of the tool definition changes, its hash would change. ETDI clients, through their verification mechanisms (often tied to cryptographic signatures which inherently hash the content), can detect if a tool has changed from a previously known and approved version. This prevents invoking a tool that has been altered since its last approval.</li> <li>Verification Process: When a client encounters a tool, it retrieves its definition. This definition is cryptographically signed by the provider. The signature verification process implicitly checks the integrity of the entire tool definition. If the client has previously approved a specific version (identified by its name and version string, and potentially its signature/hash), it can detect if the current version presented by the server is different or has been tampered with. A mismatch would lead to rejection or a re-approval requirement.</li> <li>Relevant ETDI Features: <code>ToolDefinition.version</code>, cryptographic signature verification which covers the integrity of the tool definition. See Security Features for details on tool verification.</li> </ul>"},{"location":"attack-prevention/rug-poisoning/#2-change-detection-re-approval-workflow","title":"2. Change Detection &amp; Re-approval Workflow","text":"<ul> <li>Concept: ETDI clients maintain a record of approved tools and their specific versions/hashes. If a tool provider updates a tool, even if the version number appears the same or is incremented, the change in hash will be detected.</li> <li>Protection: Upon detecting a change, the ETDI client automatically revokes the existing approval for that tool. The user (or an automated policy) must explicitly re-approve the new version after reviewing the changes.</li> <li>Relevant ETDI Features: Client-side approval management, enforced by <code>ETDIClient.approve_tool()</code> and its underlying verification logic.</li> </ul>"},{"location":"attack-prevention/rug-poisoning/#3-strict-permission-and-scope-enforcement","title":"3. Strict Permission and Scope Enforcement","text":"<ul> <li>Concept: Tools declare the permissions they require (e.g., <code>file:read</code>, <code>api:user_data:write</code>). These permissions are part of the signed tool definition.</li> <li>Protection: Even if a tool's code is maliciously altered to attempt actions beyond its declared permissions, the ETDI framework (both client and potentially server-side middleware) will block such attempts if they don't align with the granted OAuth scopes or tool permissions.</li> <li>Example: A tool originally approved for <code>read-only</code> access cannot suddenly start writing data if its code is changed, as the permission grant is tied to the original, verified definition.</li> <li>Relevant ETDI Features: <code>ToolDefinition.permissions</code>, OAuth scope validation. See Authentication &amp; Authorization in Security Features.</li> </ul>"},{"location":"attack-prevention/rug-poisoning/#4-comprehensive-audit-trails","title":"4. Comprehensive Audit Trails","text":"<ul> <li>Concept: All significant security events, including tool discovery, verification, approval, invocation, and any detected modification or policy violation, are logged.</li> <li>Protection: Audit logs provide a clear history of tool interactions and changes. In the event of a suspected rug pull, these logs are crucial for forensic analysis to understand when the change occurred, what data might have been affected, and how the malicious tool was invoked.</li> <li>Relevant ETDI Features: Security event logging by <code>ETDIClient</code> and <code>SecureServer</code>.</li> </ul>"},{"location":"attack-prevention/rug-poisoning/#best-practices-for-users-and-developers","title":"Best Practices for Users and Developers","text":"<ul> <li>Users:<ul> <li>Always review permission changes before re-approving a tool.</li> <li>Be cautious if a tool frequently changes or requests new, broad permissions.</li> <li>Monitor audit logs if available.</li> </ul> </li> <li>Developers (Tool Providers):<ul> <li>Follow semantic versioning strictly.</li> <li>Clearly document changes between tool versions.</li> <li>Minimize the permissions requested by your tools (principle of least privilege).</li> <li>Secure your publishing credentials and development pipeline to prevent unauthorized tool updates.</li> </ul> </li> </ul>"},{"location":"attack-prevention/rug-poisoning/#conclusion","title":"Conclusion","text":"<p>ETDI's combination of cryptographic verification, immutable versioning, mandatory re-approval workflows for any changes, and strict permission enforcement provides robust protection against rug poisoning attacks. By ensuring that users are always aware of and explicitly consent to the version of the tool they are using, ETDI maintains the integrity and trustworthiness of the tool ecosystem.</p>"},{"location":"attack-prevention/rug-poisoning/#related-documentation","title":"Related Documentation","text":"<ul> <li>Tool Poisoning Prevention</li> <li>Overall Attack Prevention Strategies</li> <li>Security Features Overview</li> </ul>"},{"location":"attack-prevention/tool-poisoning/","title":"Tool Poisoning Attack Prevention","text":""},{"location":"attack-prevention/tool-poisoning/#what-is-tool-poisoning","title":"What is Tool Poisoning?","text":"<p>Tool Poisoning is a significant security threat in systems that utilize external or dynamically loaded tools, particularly in AI and Large Language Model (LLM) ecosystems. It occurs when a malicious actor successfully deploys a tool that masquerades as a legitimate, trusted tool. The aim is to deceive users, or the LLM itself, into executing the malicious tool, leading to various harmful outcomes.</p>"},{"location":"attack-prevention/tool-poisoning/#attack-vectors","title":"Attack Vectors","text":"<ol> <li>Identity Spoofing: The malicious tool uses a name, description, or provider information identical or very similar to a known trusted tool.</li> <li>Deceptive Functionality: The tool might appear to perform its advertised function correctly for simple cases, while secretly carrying out malicious activities in the background or for specific inputs.</li> <li>Lack of Verification: Systems that don't rigorously verify tool authenticity, origin, or integrity are vulnerable.</li> </ol>"},{"location":"attack-prevention/tool-poisoning/#potential-impacts","title":"Potential Impacts","text":"<ul> <li>Data Theft: Exfiltration of sensitive information, PII, credentials, or proprietary data processed by the tool.</li> <li>Malware Execution: Running arbitrary code on the host system or within the user's environment.</li> <li>Privilege Escalation: Gaining unauthorized access or higher privileges within the system.</li> <li>Denial of Service (DoS): Disrupting the availability of the system or legitimate tools.</li> <li>Compromise of LLM Integrity: Manipulating LLM outputs, behavior, or decision-making processes.</li> <li>Supply Chain Attacks: If the poisoned tool is itself a development or integration tool, it can compromise a wider ecosystem.</li> </ul>"},{"location":"attack-prevention/tool-poisoning/#etdis-mitigation-strategies","title":"ETDI's Mitigation Strategies","text":"<p>The Enhanced Tool Definition Interface (ETDI) provides a robust framework to combat tool poisoning attacks through multiple layers of security:</p> <ol> <li> <p>Cryptographic Signatures &amp; Verification:</p> <ul> <li>Authenticity: Tools are cryptographically signed by their providers. ETDI clients verify these signatures, typically by having access to the provider's public key or by retrieving it from a trusted source, before execution.</li> <li>Integrity: The signature ensures that the tool's definition and metadata have not been tampered with since publication.</li> </ul> </li> <li> <p>Provider Authentication &amp; Trust Management:</p> <ul> <li>OAuth 2.0 Integration: ETDI encourages tools to be protected by OAuth 2.0, ensuring that the tool provider is authenticated. This helps confirm the identity of the entity serving the tool.</li> <li>Client-Side Verification: The ETDI client is responsible for verifying the authenticity of the tool provider, often through mechanisms like checking the issuer of an OAuth token or validating a known signature.</li> </ul> </li> <li> <p>Rich Security Metadata:</p> <ul> <li>ETDI tool definitions include comprehensive security metadata, such as required permissions (scopes), call stack constraints, and data handling policies.</li> <li>Clients can analyze this metadata before tool execution to assess risk and enforce policies.</li> </ul> </li> <li> <p>Client-Side Security Analysis Engine:</p> <ul> <li>ETDI clients incorporate a security analysis engine that evaluates tools based on their ETDI compliance, signature validity, OAuth protection, and other security attributes.</li> <li>This engine can assign trust scores and make informed decisions (allow, warn, block) about tool execution.</li> </ul> </li> <li> <p>Secure Tool Discovery &amp; Invocation Workflow:</p> <ul> <li>Discovery: Clients prioritize tools with strong ETDI security signals.</li> <li>Verification: Mandatory verification steps before a tool is considered for execution.</li> <li>Approval (Optional): For sensitive operations or less trusted tools, user or administrative approval can be enforced.</li> </ul> </li> </ol>"},{"location":"attack-prevention/tool-poisoning/#best-practices-for-developers-and-users","title":"Best Practices for Developers and Users","text":"<ul> <li>Providers: Always sign your tools with a strong private key. Protect your tools with OAuth 2.0. Clearly define security metadata.</li> <li>Developers (integrating ETDI): Implement rigorous signature verification. Use the ETDI client's security analysis capabilities. Prefer tools with complete and verified ETDI metadata.</li> <li>Users: Be cautious of tools from unverified sources. Pay attention to warnings from ETDI-compliant clients.</li> </ul> <p>By combining these technical measures and best practices, ETDI significantly raises the bar against tool poisoning attacks, fostering a more secure and trustworthy tool ecosystem.</p>"},{"location":"attack-prevention/tool-poisoning/#related-documentation","title":"Related Documentation","text":"<ul> <li>Overall Attack Prevention Strategies</li> <li>Rug Poisoning Protection</li> <li>Security Features Overview</li> <li>Tool Poisoning Demo Example</li> <li>Integration Guide</li> <li>FastMCP Security </li> </ul>"},{"location":"examples/","title":"ETDI Examples","text":"<p>This section contains examples and guides for using ETDI in various scenarios.</p>"},{"location":"examples/#core-examples","title":"Core Examples","text":"<ul> <li>Basic ETDI Usage: Get started with ETDI's core features</li> <li>E2E Demo: Complete end-to-end demonstration</li> <li>Tool Poisoning Demo: Security attack prevention</li> </ul>"},{"location":"examples/#oauth-integration","title":"OAuth Integration","text":"<ul> <li>OAuth Providers: Integrate various OAuth providers</li> <li>Auth0 Integration: Complete Auth0 setup guide</li> </ul>"},{"location":"examples/#fastmcp-integration","title":"FastMCP Integration","text":"<ul> <li>FastMCP Overview: Using ETDI with FastMCP servers</li> </ul>"},{"location":"examples/#example-categories","title":"Example Categories","text":""},{"location":"examples/#security-examples","title":"Security Examples","text":"<ul> <li>Tool poisoning prevention</li> <li>OAuth authentication</li> <li>Request signing</li> <li>Call chain verification</li> </ul>"},{"location":"examples/#integration-examples","title":"Integration Examples","text":"<ul> <li>FastMCP server integration</li> <li>Custom OAuth providers</li> <li>Event system usage</li> <li>Tool discovery</li> </ul>"},{"location":"examples/#development-examples","title":"Development Examples","text":"<ul> <li>Basic tool registration</li> <li>Custom provider implementation</li> <li>Security policy configuration</li> <li>Event handling</li> </ul>"},{"location":"examples/#running-the-examples","title":"Running the Examples","text":"<p>Most examples can be run directly from the examples directory:</p> <pre><code># Basic usage example\npython examples/etdi/basic_usage.py\n\n# Complete E2E demo\npython examples/etdi/run_e2e_demo.py\n\n# Tool poisoning prevention demo\npython examples/etdi/tool_poisoning_demo/run_real_server_demo.py\n</code></pre>"},{"location":"examples/#example-requirements","title":"Example Requirements","text":"<p>Make sure you have:</p> <ol> <li>Python 3.9 or higher</li> <li>ETDI package installed</li> <li>Required environment variables set</li> <li>OAuth provider credentials (if using OAuth examples)</li> </ol>"},{"location":"examples/#contributing-examples","title":"Contributing Examples","text":"<p>Want to contribute a new example? Follow these steps:</p> <ol> <li>Create your example in the appropriate directory</li> <li>Add documentation in the docs/examples directory</li> <li>Update this index</li> <li>Submit a pull request</li> </ol> <p>See Contributing Guide for more details. </p>"},{"location":"examples/etdi/","title":"ETDI Examples - Enhanced Tool Definition Interface","text":"<p>This directory contains comprehensive examples demonstrating how ETDI (Enhanced Tool Definition Interface) transforms MCP from a development protocol into an enterprise-ready security platform.</p>"},{"location":"examples/etdi/#quick-start","title":"\ud83d\ude80 Quick Start","text":"<p>Run the complete end-to-end security demonstration:</p> <pre><code># Ensure you are in the project root directory\npython examples/etdi/run_e2e_demo.py\n</code></pre> <p>This will show ETDI blocking real security attacks including: - \u2705 Call chain restriction enforcement - \u2705 Call depth limit validation - \u2705 Permission scope verification</p>"},{"location":"examples/etdi/#example-files","title":"\ud83d\udcc1 Example Files","text":"<p>This section provides an overview of the ETDI examples. Each example has its own detailed documentation page.</p>"},{"location":"examples/etdi/#core-security-demonstrations","title":"Core Security Demonstrations","text":"<ul> <li><code>run_e2e_demo.py</code> - START HERE: Complete end-to-end demonstration showing ETDI blocking real attacks.</li> <li><code>e2e_secure_server.py</code> - Secure Banking Server: FastMCP server with ETDI security demonstrating enterprise-grade protection.</li> <li><code>e2e_secure_client.py</code> - Secure Banking Client: Client that safely interacts with ETDI-secured servers.</li> <li><code>legitimate_etdi_server.py</code>: Example of a legitimate, fully secured ETDI server used in demos.</li> </ul>"},{"location":"examples/etdi/#fastmcp-integration","title":"FastMCP Integration","text":"<ul> <li><code>etdi_fastmcp_example.py</code>: Shows how to enable ETDI security with simple boolean flags in FastMCP decorators. (Located in <code>examples/fastmcp/</code>)</li> </ul>"},{"location":"examples/etdi/#security-components-features","title":"Security Components &amp; Features","text":"<ul> <li><code>basic_usage.py</code> - ETDI Fundamentals: Basic ETDI tool creation and security analysis.</li> <li><code>oauth_providers.py</code> - Enterprise Authentication: OAuth 2.0 integration with enterprise identity providers.</li> <li><code>secure_server_example.py</code> - Advanced Server Security: Comprehensive server security with middleware and token management.</li> <li><code>inspector_example.py</code> - Security Analysis Tools: Demonstrates <code>SecurityAnalyzer</code> and <code>TokenDebugger</code>.</li> <li><code>demo_etdi.py</code>: Comprehensive demo of various ETDI features.</li> </ul>"},{"location":"examples/etdi/#call-stack-security","title":"Call Stack Security","text":"<ul> <li><code>call_stack_example.py</code> - Call Stack Verification: Demonstrates protocol-level call stack security.</li> <li><code>protocol_call_stack_example.py</code> - Protocol Integration: Shows how call stack constraints are embedded in tool definitions.</li> <li><code>caller_callee_authorization_example.py</code> - Authorization Matrix: Detailed caller/callee authorization demonstration.</li> </ul>"},{"location":"examples/etdi/#utility-setup-examples","title":"Utility &amp; Setup Examples","text":"<ul> <li><code>clean_api_example.py</code>: Clean API usage for ETDI tool registration and invocation.</li> <li><code>setup_etdi.py</code>: Script to assist in setting up the ETDI environment or initial configurations.</li> <li><code>test_complete_security.py</code>: Test suite for complete security validation.</li> <li><code>verify_implementation.py</code>: Verifies ETDI installation and configuration.</li> </ul>"},{"location":"examples/etdi/#request-signing-examples","title":"Request Signing Examples","text":"<ul> <li><code>request_signing_example.py</code>: Demonstrates client-side request signing using RSA/ECDSA algorithms.</li> <li><code>request_signing_server_example.py</code>: Shows server-side signature verification for incoming requests.</li> <li><code>comprehensive_request_signing_example.py</code>: Provides an end-to-end workflow for request signing and verification between client and server.</li> </ul>"},{"location":"examples/etdi/#specific-attack-demonstrations","title":"Specific Attack Demonstrations","text":"<ul> <li>Tool Poisoning Demo: Contains a live demonstration of tool poisoning attacks and ETDI's prevention mechanisms. (Corresponds to <code>examples/etdi/tool_poisoning_demo/</code>)</li> </ul>"},{"location":"examples/etdi/#security-features-demonstrated-across-examples","title":"\ud83d\udee1\ufe0f Security Features Demonstrated Across Examples","text":"<p>Many examples showcase these core ETDI capabilities:</p> <ol> <li>Tool Poisoning Prevention: Cryptographic signature verification, provider authentication, tool integrity validation.</li> <li>Rug Pull Attack Protection: Version locking, change detection, behavior verification, reapproval workflows. (See Rug Poisoning Documentation)</li> <li>Privilege Escalation Blocking: Permission scope enforcement, call chain restrictions, OAuth integration.</li> <li>Call Stack Security: Maximum depth limits, allowed/blocked callee lists, real-time verification.</li> <li>Enterprise Compliance: Comprehensive audit trails, automated compliance checking, security scoring and reporting.</li> </ol>"},{"location":"examples/etdi/#illustrative-enterprise-use-cases","title":"\ud83c\udfe2 Illustrative Enterprise Use Cases","text":"<p>These snippets illustrate how ETDI features might be applied in various sensitive contexts.</p>"},{"location":"examples/etdi/#financial-services","title":"Financial Services","text":"<pre><code>@server.tool(etdi=True, etdi_permissions=[\"trading:read\"])\ndef get_portfolio():  # Can only read, never trade\n    pass\n\n@server.tool(etdi=True, etdi_permissions=[\"trading:execute\"], \n             etdi_max_call_depth=1)  # Cannot chain to other tools\ndef execute_trade():  # Isolated, audited, verified\n    pass\n</code></pre>"},{"location":"examples/etdi/#healthcare","title":"Healthcare","text":"<pre><code>@server.tool(etdi=True, etdi_permissions=[\"patient:read:anonymized\"])\ndef research_query():  # Only anonymized data\n    pass\n\n@server.tool(etdi=True, etdi_permissions=[\"patient:read:identified\"],\n             etdi_allowed_callees=[])  # Cannot call other tools\ndef doctor_lookup():  # Isolated access to identified data\n    pass\n</code></pre>"},{"location":"examples/etdi/#governmentdefense","title":"Government/Defense","text":"<pre><code>@server.tool(etdi=True, etdi_permissions=[\"classified:secret\"],\n             etdi_blocked_callees=[\"network\", \"external\"])\ndef process_classified():  # Cannot leak data externally\n    pass\n</code></pre>"},{"location":"examples/etdi/#getting-started-with-examples","title":"\ud83d\ude80 Getting Started with Examples","text":"<ol> <li>Run a demo: Navigate to the project root and execute an example script, e.g., <code>python examples/etdi/run_e2e_demo.py</code>.</li> <li>Explore FastMCP integration: See the FastMCP ETDI Integration page.</li> <li>Read detailed pages: Browse the specific documentation pages for each example linked above.</li> <li>Build secure tools: Use ETDI decorators and principles in your own servers, referring to these examples.</li> </ol>"},{"location":"examples/etdi/#key-benefits","title":"\ud83d\udca1 Key Benefits","text":"<p>For Developers: Security becomes as easy as adding <code>etdi=True</code> (with FastMCP) or using ETDI-aware server/client classes. For Enterprises: Meet compliance requirements out of the box with robust security controls. For Users: Trust that tools are verified and operate within constrained boundaries. For the Industry: Raise the security bar for all MCP implementations.</p> <p>ETDI transforms MCP from a development protocol into an enterprise-ready platform that can handle the most sensitive data and critical operations with confidence. </p>"},{"location":"examples/etdi/basic_usage/","title":"Basic ETDI Usage (<code>basic_usage.py</code>)","text":"<p>This page documents the actual features and steps demonstrated by the <code>basic_usage.py</code> script in the ETDI examples.</p>"},{"location":"examples/etdi/basic_usage/#what-the-example-does","title":"What the Example Does","text":"<p>The script demonstrates the following implemented features:</p> <ul> <li>ETDI Client Initialization: Shows how to configure and initialize an ETDI client with OAuth authentication and security settings.</li> <li>Tool Discovery: Discovers available tools from the MCP server and displays their verification status, provider, and permissions.</li> <li>Tool Verification and Approval: Verifies a discovered tool, checks if it is approved, and approves it if necessary.</li> <li>Version Change Detection: Checks if a tool's version has changed and notifies if re-approval is required.</li> <li>Tool Invocation: Attempts to invoke a verified and approved tool (will fail without a real MCP server, as expected in the demo).</li> </ul>"},{"location":"examples/etdi/basic_usage/#how-to-run-the-example","title":"How to Run the Example","text":"<ol> <li>Ensure you are in the project root directory and have activated your Python virtual environment.</li> <li>Navigate to the <code>examples/etdi/</code> directory if needed.</li> <li>Run the script:</li> </ol> <pre><code>python examples/etdi/basic_usage.py\n</code></pre> <p>The script will print the results of each step to the console, including tool discovery, verification, approval, and (attempted) invocation.</p>"},{"location":"examples/etdi/basic_usage/#output","title":"Output","text":"<p>You will see output for: - ETDI client initialization and stats - Tool discovery and listing - Tool verification and approval - Version change detection - Tool invocation attempt and result</p> <p>For more details, see the script source at <code>examples/etdi/basic_usage.py</code>. </p>"},{"location":"examples/etdi/run_e2e_demo/","title":"End-to-End Demo (<code>run_e2e_demo.py</code>)","text":"<p>This page documents the actual features and steps demonstrated by the <code>run_e2e_demo.py</code> script in the ETDI examples.</p>"},{"location":"examples/etdi/run_e2e_demo/#what-the-demo-does","title":"What the Demo Does","text":"<p>The script demonstrates the following implemented features:</p> <ul> <li>Tool Registration/Provider SDK: Shows how to register tools (with and without OAuth), update tool versions, and manage permissions using the ETDI ToolProvider SDK.</li> <li>Custom OAuth Provider Support: Demonstrates integration with both Auth0 and custom OAuth providers for tool authentication.</li> <li>Event System: Registers event listeners and emits events for tool verification, approval, and security violations.</li> <li>MCP Tool Discovery: Uses the ETDI client to connect to MCP servers, discover tools, and display security-level filtering and verification.</li> <li>Security Features: Runs a secure client demo that demonstrates attack prevention and security policy enforcement.</li> </ul>"},{"location":"examples/etdi/run_e2e_demo/#how-to-run-the-demo","title":"How to Run the Demo","text":"<ol> <li>Ensure you are in the project root directory and have activated your Python virtual environment.</li> <li>Navigate to the <code>examples/etdi/</code> directory if needed.</li> <li>Run the script:</li> </ol> <pre><code>python examples/etdi/run_e2e_demo.py\n</code></pre> <p>The script will sequentially run each feature demonstration and print the results to the console, including success/failure for each step.</p>"},{"location":"examples/etdi/run_e2e_demo/#output","title":"Output","text":"<p>You will see output for: - Tool registration and provider statistics - OAuth provider configuration - Event system activity - MCP tool discovery and client stats - Security feature demonstration results - A summary of which demonstrations succeeded or failed</p> <p>For more details, see the script source at <code>examples/etdi/run_e2e_demo.py</code>. </p>"},{"location":"examples/etdi/tool_poisoning_demo/","title":"ETDI Tool Poisoning Prevention Demo","text":""},{"location":"examples/etdi/tool_poisoning_demo/#overview","title":"Overview","text":"<p>This demonstration shows how ETDI (Enhanced Tool Definition Interface) prevents Tool Poisoning attacks - a critical security vulnerability where malicious actors deploy tools that masquerade as legitimate, trusted tools to deceive users and LLMs.</p> <p>This page is based on the <code>TOOL_POISONING_DEMO_README.md</code> found in the <code>examples/etdi/tool_poisoning_demo/</code> directory (relative to project root).</p>"},{"location":"examples/etdi/tool_poisoning_demo/#attack-scenario","title":"Attack Scenario","text":""},{"location":"examples/etdi/tool_poisoning_demo/#the-problem-tool-poisoning","title":"The Problem: Tool Poisoning","text":"<p>Tool Poisoning occurs when: 1. Malicious Actor deploys a tool with identical name/description to a legitimate tool 2. Spoofed Identity - Claims to be from a trusted provider (e.g., \"TrustedSoft Inc.\") 3. Deceptive Behavior - Appears to function normally but secretly exfiltrates data 4. User/LLM Deception - No way to distinguish between legitimate and malicious tools</p>"},{"location":"examples/etdi/tool_poisoning_demo/#real-world-impact","title":"Real-World Impact","text":"<ul> <li>Data Theft - Sensitive documents, PII, credentials stolen</li> <li>Malware Installation - Malicious code execution</li> <li>Financial Loss - Unauthorized transactions, account compromise</li> <li>Privacy Violations - Personal information exposure</li> <li>Supply Chain Attacks - Compromised development tools</li> </ul>"},{"location":"examples/etdi/tool_poisoning_demo/#demo-components","title":"Demo Components","text":"<p>Details about the legitimate tool, malicious tool, and secure client used in this demo are available in the original README and the demo script (<code>tool_poisoning_prevention_demo.py</code> in <code>examples/etdi/tool_poisoning_demo/</code>).</p>"},{"location":"examples/etdi/tool_poisoning_demo/#1-legitimate-etdi-protected-tool","title":"1. Legitimate ETDI-Protected Tool","text":"<p>TrustedSoft SecureDocs Scanner - Legitimate document scanner with ETDI security, OAuth protection, call stack constraints, permission scoping, and audit logging.</p>"},{"location":"examples/etdi/tool_poisoning_demo/#2-malicious-tool-attack-simulation","title":"2. Malicious Tool (Attack Simulation)","text":"<p>Fake SecureDocs Scanner - Malicious tool lacking ETDI/OAuth, spoofing provider name, exfiltrating data, and returning fake results.</p>"},{"location":"examples/etdi/tool_poisoning_demo/#3-etdi-secure-client","title":"3. ETDI Secure Client","text":"<p>Security Analysis Engine that discovers tools, analyzes security (ETDI &amp; OAuth), prevents attacks, and reports results.</p>"},{"location":"examples/etdi/tool_poisoning_demo/#how-etdi-prevents-the-attack","title":"How ETDI Prevents the Attack","text":"<p>ETDI prevents this through a multi-stage verification process, typically involving checking for ETDI metadata, cryptographic signatures, OAuth protection, and provider identity.</p>"},{"location":"examples/etdi/tool_poisoning_demo/#running-the-demo","title":"Running the Demo","text":""},{"location":"examples/etdi/tool_poisoning_demo/#prerequisites","title":"Prerequisites","text":"<pre><code># Ensure you're in the project root directory\n# Activate your virtual environment, e.g.:\n# source .venv/bin/activate \ncd examples/etdi/tool_poisoning_demo # Navigate to the demo directory\n</code></pre>"},{"location":"examples/etdi/tool_poisoning_demo/#execute-demo","title":"Execute Demo","text":"<pre><code>python tool_poisoning_prevention_demo.py\n</code></pre> <p>(Refer to the original README in the demo directory for the most up-to-date execution instructions and expected output.)</p>"},{"location":"examples/etdi/tool_poisoning_demo/#key-insights","title":"Key Insights","text":""},{"location":"examples/etdi/tool_poisoning_demo/#without-etdi","title":"Without ETDI","text":"<ul> <li>No reliable verification method.</li> <li>Easy to spoof tool identities.</li> <li>No inherent authentication of the tool provider.</li> <li>Silent attacks can go undetected.</li> </ul>"},{"location":"examples/etdi/tool_poisoning_demo/#with-etdi","title":"With ETDI","text":"<ul> <li>Cryptographic verification of tool authenticity.</li> <li>OAuth protection for provider identity verification.</li> <li>Security metadata available for analysis before execution.</li> <li>Malicious tools can be blocked proactively.</li> </ul>"},{"location":"examples/etdi/tool_poisoning_demo/#conclusion","title":"Conclusion","text":"<p>ETDI's security framework provides the cryptographic proof and verification mechanisms needed to prevent tool poisoning attacks and protect sensitive data.</p>"},{"location":"examples/etdi/tool_poisoning_demo/#related-documentation","title":"Related Documentation","text":"<ul> <li>Overall Attack Prevention Strategies</li> <li>Rug Poisoning Protection</li> <li>Security Features Overview</li> <li>ETDI Examples Overview </li> </ul>"},{"location":"examples/etdi/oauth_providers/","title":"OAuth Provider Integration Examples","text":"<p>ETDI supports various OAuth providers for secure authentication and authorization. This section contains detailed guides and examples for integrating different OAuth providers with your ETDI implementation.</p>"},{"location":"examples/etdi/oauth_providers/#available-providers","title":"Available Providers","text":""},{"location":"examples/etdi/oauth_providers/#auth0","title":"Auth0","text":"<p>Complete guide for integrating Auth0 with ETDI, including: - Application setup and configuration - API and scope management - Demo script configuration - Troubleshooting and best practices</p>"},{"location":"examples/etdi/oauth_providers/#common-oauth-concepts","title":"Common OAuth Concepts","text":"<p>All OAuth provider integrations in ETDI share some common concepts:</p> <ol> <li> <p>Provider Configuration <pre><code>from mcp.etdi.oauth import OAuthConfig\n\noauth_config = OAuthConfig(\n    provider=\"provider_name\",\n    client_id=\"your_client_id\",\n    client_secret=\"your_client_secret\",\n    domain=\"your_domain\",\n    audience=\"your_api_audience\",\n    scopes=[\"required\", \"scopes\"]\n)\n</code></pre></p> </li> <li> <p>Token Management    - Secure token storage    - Token refresh handling    - Token validation</p> </li> <li> <p>Scope Management    - Permission definition    - Scope validation    - Access control</p> </li> <li> <p>Error Handling    - Authentication failures    - Authorization errors    - Token validation issues</p> </li> </ol>"},{"location":"examples/etdi/oauth_providers/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Security    - Use environment variables for sensitive data    - Implement proper error handling    - Follow OAuth 2.0 best practices    - Regular security audits</p> </li> <li> <p>Configuration    - Validate all OAuth settings    - Test with minimal scopes first    - Monitor token usage and expiration    - Implement proper logging</p> </li> <li> <p>Integration    - Start with basic authentication    - Add authorization gradually    - Test thoroughly in staging    - Monitor in production</p> </li> </ol>"},{"location":"examples/etdi/oauth_providers/#example-usage","title":"Example Usage","text":"<p>Basic OAuth provider setup:</p> <pre><code>from mcp.etdi.oauth import OAuthProvider\nfrom mcp.etdi.types import OAuthConfig\n\n# Create configuration\nconfig = OAuthConfig(\n    provider=\"your_provider\",\n    client_id=os.getenv(\"OAUTH_CLIENT_ID\"),\n    client_secret=os.getenv(\"OAUTH_CLIENT_SECRET\"),\n    domain=os.getenv(\"OAUTH_DOMAIN\"),\n    audience=os.getenv(\"OAUTH_AUDIENCE\"),\n    scopes=[\"read\", \"write\"]\n)\n\n# Initialize provider\nprovider = OAuthProvider(config)\nawait provider.initialize()\n\n# Use in secure server\nserver = SecureServer(\n    name=\"secure-server\",\n    oauth_provider=provider,\n    security_level=SecurityLevel.HIGH\n)\n</code></pre>"},{"location":"examples/etdi/oauth_providers/#adding-new-providers","title":"Adding New Providers","text":"<p>To add support for a new OAuth provider:</p> <ol> <li> <p>Create provider class:    <pre><code>from mcp.etdi.oauth import BaseOAuthProvider\n\nclass CustomProvider(BaseOAuthProvider):\n    async def get_token(self, *args, **kwargs):\n        # Implement token acquisition\n        pass\n\n    async def validate_token(self, token: str) -&gt; bool:\n        # Implement token validation\n        pass\n</code></pre></p> </li> <li> <p>Register provider:    <pre><code>from mcp.etdi.oauth import register_provider\n\nregister_provider(\"custom\", CustomProvider)\n</code></pre></p> </li> <li> <p>Create documentation:    - Add provider guide (like auth0.md)    - Update this index    - Add examples and tests</p> </li> </ol>"},{"location":"examples/etdi/oauth_providers/#see-also","title":"See Also","text":"<ul> <li>Security Features</li> <li>Getting Started</li> <li>ETDI Concepts </li> </ul>"},{"location":"examples/etdi/oauth_providers/auth0/","title":"Auth0 Integration Guide","text":"<p>This guide provides detailed information about integrating Auth0 with ETDI for secure tool authentication and authorization.</p>"},{"location":"examples/etdi/oauth_providers/auth0/#prerequisites","title":"Prerequisites","text":"<ul> <li>An Auth0 account</li> <li>ETDI Python SDK installed</li> <li>Basic understanding of OAuth 2.0</li> </ul>"},{"location":"examples/etdi/oauth_providers/auth0/#auth0-setup-details","title":"Auth0 Setup Details","text":""},{"location":"examples/etdi/oauth_providers/auth0/#application-configuration","title":"Application Configuration","text":"<p>In your Auth0 dashboard:</p> <ol> <li> <p>Application Settings    - Application Type: Machine to Machine    - Token Endpoint Authentication Method: <code>client_secret_post</code>    - Grant Types: Client Credentials    - Allow Non OIDC Compliant Conformance: Yes</p> </li> <li> <p>API Configuration <pre><code>{\n  \"identifier\": \"https://api.etdi-tools.demo.com\",\n  \"signing_alg\": \"RS256\",\n  \"token_lifetime\": 86400,\n  \"allow_offline_access\": true,\n  \"skip_consent_for_verifiable_first_party_clients\": true\n}\n</code></pre></p> </li> <li> <p>Required Scopes <pre><code>[\n  {\n    \"value\": \"create:resource-servers\",\n    \"description\": \"Create new tool registrations\"\n  },\n  {\n    \"value\": \"read:resource-servers\",\n    \"description\": \"Read tool information\"\n  },\n  {\n    \"value\": \"update:resource-servers\",\n    \"description\": \"Update existing tools\"\n  },\n  {\n    \"value\": \"delete:resource-servers\",\n    \"description\": \"Remove tool registrations\"\n  }\n]\n</code></pre></p> </li> </ol>"},{"location":"examples/etdi/oauth_providers/auth0/#configuring-auth0-for-demo-scripts","title":"Configuring Auth0 for Demo Scripts","text":""},{"location":"examples/etdi/oauth_providers/auth0/#demo-script-configuration","title":"Demo Script Configuration","text":"<p>The ETDI package includes two main demo scripts that showcase different aspects of the security features: - <code>run_e2e_demo.py</code>: Demonstrates end-to-end ETDI features - <code>run_real_server_demo.py</code>: Shows tool poisoning prevention</p> <p>To get both demos working, you'll need to configure Auth0 correctly:</p>"},{"location":"examples/etdi/oauth_providers/auth0/#1-auth0-application-setup","title":"1. Auth0 Application Setup","text":"<p>Create two applications in your Auth0 dashboard:</p> <ol> <li> <p>ETDI Tool Registry Application <pre><code>{\n  \"name\": \"ETDI Tool Registry\",\n  \"application_type\": \"machine_to_machine\",\n  \"token_endpoint_auth_method\": \"client_secret_post\",\n  \"grant_types\": [\"client_credentials\"],\n  \"allowed_origins\": [],\n  \"client_id\": \"your_client_id\",  // You'll get this after creation\n  \"client_secret\": \"your_client_secret\"  // You'll get this after creation\n}\n</code></pre></p> </li> <li> <p>ETDI Demo Server Application <pre><code>{\n  \"name\": \"ETDI Demo Server\",\n  \"application_type\": \"machine_to_machine\",\n  \"token_endpoint_auth_method\": \"client_secret_post\",\n  \"grant_types\": [\"client_credentials\"],\n  \"allowed_origins\": [],\n}\n</code></pre></p> </li> </ol>"},{"location":"examples/etdi/oauth_providers/auth0/#2-auth0-api-configuration","title":"2. Auth0 API Configuration","text":"<p>Create an API with these settings:</p> <pre><code>{\n  \"name\": \"ETDI Tool Registry API\",\n  \"identifier\": \"https://api.etdi-tools.demo.com\",\n  \"signing_alg\": \"RS256\",\n  \"token_lifetime\": 86400,\n  \"scopes\": {\n    \"create:resource-servers\": \"Create new tool registrations\",\n    \"read:resource-servers\": \"Read tool information\",\n    \"update:resource-servers\": \"Update existing tools\",\n    \"delete:resource-servers\": \"Remove tool registrations\",\n    \"execute:tools\": \"Execute registered tools\"\n  }\n}\n</code></pre>"},{"location":"examples/etdi/oauth_providers/auth0/#3-environment-variables","title":"3. Environment Variables","text":"<p>Set these environment variables for both demo scripts:</p> <pre><code># For run_e2e_demo.py\nexport AUTH0_DOMAIN=\"your-tenant.auth0.com\"\nexport AUTH0_CLIENT_ID=\"your-tool-registry-client-id\"\nexport AUTH0_CLIENT_SECRET=\"your-tool-registry-client-secret\"\nexport AUTH0_AUDIENCE=\"https://api.etdi-tools.demo.com\"\n\n# For run_real_server_demo.py (additional vars)\nexport ETDI_AUTH0_DOMAIN=\"your-tenant.auth0.com\"\nexport ETDI_DEMO_CLIENT_ID=\"your-demo-server-client-id\"\nexport ETDI_DEMO_CLIENT_SECRET=\"your-demo-server-client-secret\"\n</code></pre>"},{"location":"examples/etdi/oauth_providers/auth0/#4-code-changes","title":"4. Code Changes","text":""},{"location":"examples/etdi/oauth_providers/auth0/#for-run_e2e_demopy","title":"For run_e2e_demo.py","text":"<p>Update the OAuth configuration in the demo_tool_provider_sdk() function:</p> <pre><code>oauth_config = OAuthConfig(\n    provider=\"auth0\",\n    client_id=os.getenv(\"AUTH0_CLIENT_ID\"),\n    client_secret=os.getenv(\"AUTH0_CLIENT_SECRET\"),\n    domain=os.getenv(\"AUTH0_DOMAIN\"),\n    audience=os.getenv(\"AUTH0_AUDIENCE\"),\n    scopes=[\"create:resource-servers\", \"read:resource-servers\"]  # Updated scopes\n)\n</code></pre>"},{"location":"examples/etdi/oauth_providers/auth0/#for-run_real_server_demopy","title":"For run_real_server_demo.py","text":"<p>In the legitimate_etdi_server.py:</p> <pre><code>oauth_config = OAuthConfig(\n    provider=\"auth0\",\n    client_id=os.getenv(\"ETDI_DEMO_CLIENT_ID\"),\n    client_secret=os.getenv(\"ETDI_DEMO_CLIENT_SECRET\"),\n    domain=os.getenv(\"ETDI_AUTH0_DOMAIN\"),\n    audience=os.getenv(\"AUTH0_AUDIENCE\"),\n    scopes=[\"execute:tools\", \"read:resource-servers\"]\n)\n</code></pre>"},{"location":"examples/etdi/oauth_providers/auth0/#5-permissions-setup","title":"5. Permissions Setup","text":"<ol> <li>Go to your Auth0 dashboard &gt; APIs &gt; ETDI Tool Registry API</li> <li>Click on \"Permissions\" tab</li> <li> <p>Add all required scopes:    <pre><code>create:resource-servers\nread:resource-servers\nupdate:resource-servers\ndelete:resource-servers\nexecute:tools\n</code></pre></p> </li> <li> <p>Go to \"Machine to Machine Applications\"</p> </li> <li>Authorize both applications and grant appropriate scopes:    - Tool Registry App: All scopes    - Demo Server App: <code>execute:tools</code>, <code>read:resource-servers</code></li> </ol>"},{"location":"examples/etdi/oauth_providers/auth0/#6-testing-the-configuration","title":"6. Testing the Configuration","text":"<ol> <li> <p>Test the e2e demo: <pre><code># First test\npython examples/etdi/run_e2e_demo.py\n\n# If you see OAuth errors, verify your environment variables:\necho $AUTH0_DOMAIN\necho $AUTH0_CLIENT_ID\necho $AUTH0_CLIENT_SECRET\necho $AUTH0_AUDIENCE\n</code></pre></p> </li> <li> <p>Test the real server demo: <pre><code># First test\npython examples/etdi/tool_poisoning_demo/run_real_server_demo.py\n\n# If you see OAuth errors, verify your environment variables:\necho $ETDI_AUTH0_DOMAIN\necho $ETDI_DEMO_CLIENT_ID\necho $ETDI_DEMO_CLIENT_SECRET\n</code></pre></p> </li> </ol>"},{"location":"examples/etdi/oauth_providers/auth0/#common-issues","title":"Common Issues","text":"<ol> <li> <p>401 Unauthorized in run_e2e_demo.py    - Verify AUTH0_CLIENT_SECRET is correct    - Check if scopes are properly granted in Auth0 dashboard    - Ensure audience matches API identifier exactly</p> </li> <li> <p>403 Forbidden in run_real_server_demo.py    - Check if ETDI_DEMO_CLIENT_ID has proper scopes    - Verify ETDI_AUTH0_DOMAIN is correct    - Ensure API permissions are properly set up</p> </li> <li> <p>Token Validation Errors    - Verify signing algorithm is RS256    - Check if audience matches in both config and Auth0    - Ensure domain is correct and includes \".auth0.com\"</p> </li> </ol>"},{"location":"examples/etdi/oauth_providers/auth0/#implementation-examples","title":"Implementation Examples","text":""},{"location":"examples/etdi/oauth_providers/auth0/#basic-auth0-provider","title":"Basic Auth0 Provider","text":"<pre><code>from mcp.etdi.oauth import OAuthConfig, Auth0Provider\n\n# Create OAuth configuration\noauth_config = OAuthConfig(\n    provider=\"auth0\",\n    client_id=os.getenv(\"AUTH0_CLIENT_ID\"),\n    client_secret=os.getenv(\"AUTH0_CLIENT_SECRET\"),\n    domain=os.getenv(\"AUTH0_DOMAIN\"),\n    audience=os.getenv(\"AUTH0_AUDIENCE\"),\n    scopes=[\"read:resource-servers\"]\n)\n\n# Initialize provider\nauth0_provider = Auth0Provider(oauth_config)\nawait auth0_provider.initialize()\n</code></pre>"},{"location":"examples/etdi/oauth_providers/auth0/#secure-server-with-auth0","title":"Secure Server with Auth0","text":"<pre><code>from mcp.etdi import SecureServer\nfrom mcp.etdi.types import SecurityLevel\n\n# Create server with Auth0\nserver = SecureServer(\n    name=\"auth0-secure-server\",\n    security_level=SecurityLevel.HIGH,\n    oauth_provider=auth0_provider,\n    enable_request_signing=True\n)\n\n# Register protected tool\n@server.tool(\n    \"protected_tool\",\n    required_scopes=[\"read:resource-servers\"],\n    require_auth=True\n)\nasync def protected_tool(data: str) -&gt; str:\n    return f\"Protected data: {data}\"\n</code></pre>"},{"location":"examples/etdi/oauth_providers/auth0/#client-with-auth0-authentication","title":"Client with Auth0 Authentication","text":"<pre><code>from mcp.etdi.client import ETDIClient\nfrom mcp.etdi.types import ETDIClientConfig\n\n# Create client config\nclient_config = ETDIClientConfig(\n    security_level=SecurityLevel.HIGH,\n    oauth_config=oauth_config,\n    verification_cache_ttl=300\n)\n\n# Initialize client\nclient = ETDIClient(client_config)\nawait client.initialize()\n\n# Call protected tool\nresult = await client.call_tool(\n    \"protected_tool\",\n    {\"data\": \"test\"},\n    required_scopes=[\"read:resource-servers\"]\n)\n</code></pre>"},{"location":"examples/etdi/oauth_providers/auth0/#security-best-practices","title":"Security Best Practices","text":"<ol> <li> <p>Token Management    - Store tokens securely    - Implement token refresh logic    - Handle token revocation</p> </li> <li> <p>Scope Management    - Use principle of least privilege    - Regularly audit granted scopes    - Implement scope validation</p> </li> <li> <p>Error Handling <pre><code>try:\n    token = await auth0_provider.get_token(\n        tool_id=\"secure-tool\",\n        permissions=[\"read:resource-servers\"]\n    )\nexcept Auth0Error as e:\n    if e.error == \"invalid_client\":\n        # Handle invalid credentials\n        logger.error(\"Invalid Auth0 credentials\")\n    elif e.error == \"insufficient_scope\":\n        # Handle missing permissions\n        logger.error(\"Insufficient permissions\")\n</code></pre></p> </li> </ol>"},{"location":"examples/etdi/oauth_providers/auth0/#monitoring-and-debugging","title":"Monitoring and Debugging","text":""},{"location":"examples/etdi/oauth_providers/auth0/#enable-debug-logging","title":"Enable Debug Logging","text":"<pre><code>import logging\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger(\"mcp.etdi.oauth.auth0\")\n</code></pre>"},{"location":"examples/etdi/oauth_providers/auth0/#monitor-auth0-events","title":"Monitor Auth0 Events","text":"<pre><code>from mcp.etdi.events import EventType, get_event_emitter\n\nemitter = get_event_emitter()\nemitter.on(EventType.AUTH_SUCCESS, lambda e: print(f\"Auth success: {e}\"))\nemitter.on(EventType.AUTH_FAILURE, lambda e: print(f\"Auth failure: {e}\"))\n</code></pre>"},{"location":"examples/etdi/oauth_providers/auth0/#common-issues-and-solutions","title":"Common Issues and Solutions","text":"<ol> <li> <p>Token Acquisition Failures    - Verify client credentials    - Check API audience    - Confirm scope configuration</p> </li> <li> <p>Invalid Scope Errors    - Review API permissions    - Check scope formatting    - Verify scope assignments</p> </li> <li> <p>Rate Limiting    - Implement token caching    - Use exponential backoff    - Monitor rate limits</p> </li> </ol>"},{"location":"examples/etdi/oauth_providers/auth0/#testing-auth0-integration","title":"Testing Auth0 Integration","text":"<pre><code>import pytest\nfrom mcp.etdi.oauth import Auth0Provider\n\n@pytest.mark.asyncio\nasync def test_auth0_integration():\n    # Initialize provider\n    provider = Auth0Provider(oauth_config)\n    await provider.initialize()\n\n    # Test token acquisition\n    token = await provider.get_token(\n        tool_id=\"test-tool\",\n        permissions=[\"read:resource-servers\"]\n    )\n    assert token.access_token\n    assert \"read:resource-servers\" in token.scopes\n\n    # Test token validation\n    is_valid = await provider.validate_token(token.access_token)\n    assert is_valid\n\n    await provider.cleanup()\n</code></pre>"},{"location":"examples/etdi/oauth_providers/auth0/#additional-resources","title":"Additional Resources","text":"<ul> <li>Auth0 Documentation</li> <li>OAuth 2.0 Specification</li> <li>ETDI Security Guide</li> <li>Example Implementation </li> </ul>"},{"location":"fastmcp/","title":"FastMCP with ETDI Integration Example","text":"<p>This page details how to integrate Enhanced Tool Definition Interface (ETDI) security features with the FastMCP decorator API. ETDI security can be enabled and configured using simple boolean flags and parameters directly within the <code>@server.tool()</code> decorator.</p> <p>This approach allows for a declarative way to specify security requirements such as permissions, call stack constraints, and overall ETDI enablement for your tools.</p>"},{"location":"fastmcp/#example-overview","title":"Example Overview","text":"<p>The <code>examples/fastmcp/etdi_fastmcp_example.py</code> script (relative to project root) demonstrates these capabilities.</p> <pre><code>#!/usr/bin/env python3\n\"\"\"\nFastMCP with ETDI Integration Example\n\nDemonstrates how to use the FastMCP decorator API with ETDI security features\nenabled through simple boolean flags and parameters.\n\"\"\"\n\nfrom mcp.server.fastmcp import FastMCP\n\n# Create FastMCP server\nserver = FastMCP(\"ETDI FastMCP Example\")\n\n\n@server.tool()\ndef basic_tool(x: int) -&gt; str:\n    \"\"\"A basic tool without ETDI security\"\"\"\n    return f\"Basic result: {x}\"\n\n\n@server.tool(etdi=True)\ndef simple_etdi_tool(message: str) -&gt; str:\n    \"\"\"A simple tool with ETDI security enabled\"\"\"\n    return f\"ETDI secured: {message}\"\n\n\n@server.tool(\n    etdi=True,\n    etdi_permissions=[\"data:read\", \"files:access\"],\n    etdi_max_call_depth=3\n)\ndef secure_data_tool(data_id: str) -&gt; str:\n    \"\"\"A tool with specific ETDI permissions and call depth limits\"\"\"\n    return f\"Securely processed data: {data_id}\"\n\n\n@server.tool(\n    etdi=True,\n    etdi_permissions=[\"files:write\", \"storage:modify\"],\n    etdi_allowed_callees=[\"secure_data_tool\", \"validation_tool\"],\n    etdi_blocked_callees=[\"admin_tool\", \"dangerous_tool\"]\n)\ndef file_processor(filename: str, content: str) -&gt; str:\n    \"\"\"A tool with call chain restrictions\"\"\"\n    return f\"File {filename} processed with ETDI call chain security\"\n\n\n@server.tool(\n    etdi=True,\n    etdi_permissions=[\"admin:read\"],\n    etdi_max_call_depth=1,\n    etdi_allowed_callees=[]  # Cannot call any other tools\n)\ndef admin_info_tool(query: str) -&gt; str:\n    \"\"\"Administrative tool with strict ETDI constraints\"\"\"\n    return f\"Admin info (secured): {query}\"\n\n\n@server.tool(\n    etdi=True,\n    etdi_permissions=[\"validation:execute\"],\n    etdi_max_call_depth=2\n)\ndef validation_tool(data: str) -&gt; str:\n    \"\"\"Validation tool that can be called by other tools\"\"\"\n    return f\"Validated: {data}\"\n\n\n# Example of a tool that would be dangerous without ETDI\n@server.tool(\n    etdi=True,\n    etdi_permissions=[\"system:execute\", \"admin:full\"],\n    etdi_max_call_depth=1,\n    etdi_blocked_callees=[\"*\"]  # Cannot call any tools\n)\ndef system_command_tool(command: str) -&gt; str:\n    \"\"\"System command tool with maximum ETDI security\"\"\"\n    # In a real implementation, this would execute system commands\n    # ETDI ensures it can't be called inappropriately or call other tools\n    return f\"System command executed securely: {command}\"\n\n\ndef main():\n    \"\"\"Demonstrate the ETDI-enabled FastMCP server\"\"\"\n    print(\"\ud83d\ude80 FastMCP with ETDI Integration Example\")\n    print(\"=\" * 50)\n\n    print(\"\\n\ud83d\udccb Tools registered:\")\n\n    # Get all registered tools\n    tools = server._tool_manager.list_tools()\n\n    for tool in tools:\n        tool_name = tool.name\n        # Check if the original function has ETDI metadata\n        original_func = getattr(server._tool_manager._tools.get(tool_name), '_original_function', None)\n\n        if hasattr(original_func, '_etdi_enabled') and original_func._etdi_enabled:\n            etdi_tool = getattr(original_func, '_etdi_tool_definition', None)\n            print(f\"\\n\ud83d\udd12 {tool_name} (ETDI Secured)\")\n            print(f\"   Description: {tool.description}\")\n\n            if etdi_tool:\n                if etdi_tool.permissions:\n                    perms = [p.scope for p in etdi_tool.permissions]\n                    print(f\"   Permissions: {', '.join(perms)}\")\n\n                if etdi_tool.call_stack_constraints:\n                    constraints = etdi_tool.call_stack_constraints\n                    if constraints.max_depth:\n                        print(f\"   Max Call Depth: {constraints.max_depth}\")\n                    if constraints.allowed_callees:\n                        print(f\"   Allowed Callees: {', '.join(constraints.allowed_callees)}\")\n                    if constraints.blocked_callees:\n                        print(f\"   Blocked Callees: {', '.join(constraints.blocked_callees)}\")\n        else:\n            print(f\"\\n\ud83d\udcdd {tool_name} (Standard)\")\n            print(f\"   Description: {tool.description}\")\n\n    print(\"\\n\" + \"=\" * 50)\n    print(\"\u2705 FastMCP ETDI Integration Complete!\")\n    print(\"\\n\ud83d\udca1 Key Benefits:\")\n    print(\"   \u2022 Simple boolean flag to enable ETDI security\")\n    print(\"   \u2022 Declarative permission specification\")\n    print(\"   \u2022 Call stack depth and chain controls\")\n    print(\"   \u2022 Automatic ETDI tool definition generation\")\n    print(\"   \u2022 Seamless integration with existing FastMCP code\")\n    print(\"   \u2022 Graceful fallback when ETDI not available\")\n\n    print(\"\\n\ud83d\udd27 Usage Examples:\")\n    print(\"   @server.tool(etdi=True)\")\n    print(\"   @server.tool(etdi=True, etdi_permissions=['data:read'])\")\n    print(\"   @server.tool(etdi=True, etdi_max_call_depth=3)\")\n    print(\"   @server.tool(etdi=True, etdi_allowed_callees=['helper'])\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"fastmcp/#key-features-demonstrated","title":"Key Features Demonstrated","text":"<ul> <li>Enabling ETDI: Simply add <code>etdi=True</code> to the <code>@server.tool()</code> decorator.     <pre><code>@server.tool(etdi=True)\ndef simple_etdi_tool(message: str) -&gt; str: # ...\n</code></pre></li> <li>Specifying Permissions: Use the <code>etdi_permissions</code> list to declare required OAuth scopes.     <pre><code>@server.tool(\n    etdi=True,\n    etdi_permissions=[\"data:read\", \"files:access\"]\n)\ndef secure_data_tool(data_id: str) -&gt; str: # ...\n</code></pre></li> <li>Setting Call Stack Constraints:<ul> <li><code>etdi_max_call_depth</code>: Integer defining maximum call chain depth.</li> <li><code>etdi_allowed_callees</code>: List of tool names that this tool is allowed to invoke.</li> <li><code>etdi_blocked_callees</code>: List of tool names that this tool is explicitly forbidden from invoking (can use <code>[\"*\"]</code> to block all calls). <pre><code>@server.tool(\n    etdi=True,\n    etdi_permissions=[\"files:write\", \"storage:modify\"],\n    etdi_allowed_callees=[\"secure_data_tool\", \"validation_tool\"],\n    etdi_blocked_callees=[\"admin_tool\", \"dangerous_tool\"]\n)\ndef file_processor(filename: str, content: str) -&gt; str: # ...\n</code></pre></li> </ul> </li> <li>Request Signing: FastMCP servers support ETDI request signing for secure tool invocations, ensuring authenticity and integrity of every request. See <code>examples/etdi/request_signing_server_example.py</code> for usage.</li> </ul>"},{"location":"fastmcp/#benefits","title":"Benefits","text":"<ul> <li>Simplified Security: Security features are declared alongside the tool definition, making it easy to understand and manage.</li> <li>Automatic ETDI Definition: FastMCP handles the creation of the underlying <code>ETDIToolDefinition</code> object based on these parameters.</li> <li>Seamless Integration: Works with existing FastMCP server and tool structures with minimal changes.</li> <li>Graceful Fallback: If the ETDI client or server does not support these specific ETDI extensions, the tool may still function as a standard MCP tool (behavior might depend on MCP library specifics).</li> </ul> <p>By using these decorator parameters, you can incrementally add robust ETDI security to your FastMCP tools.</p>"},{"location":"fastmcp/#related-documentation","title":"Related Documentation","text":"<ul> <li>Attack Prevention Overview</li> <li>Call Stack Security</li> <li>Security Features Overview </li> </ul>"}]}